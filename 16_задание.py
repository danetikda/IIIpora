#Задача (Лёгкая)
#Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#F(n) = 1 при n = 1;
#F(n) = n + F(n − 1), если n – чётно,
#F(n) = 3 × F(n − 2), если n > 1 и при этом n – нечётно.
#Чему равно значение функции F(25)?
# Сама функция
def F(n):
    if n==1: return 1
    if n%2==0: return n+F(n-1)
    if n>1 and n%2!=0: return 3*F(n-2)
    
# Основная часть программы
print(F(25))
#
#
#
#
#Задача (Продолжаем подготовку)
#Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#F(1) = 1
#F(2) = 3
#F(n) = F(n–1) * n + F(n–2) * (n – 1) , при n > 2
#Чему равно значение функции F(8)? В ответе запишите только натуральное число.

# Сама функция
def F(n):
    if n==1: return 1
    if n==2: return 3
    if n>2: return F(n-1)*n + F(n-2)*(n-1)
    
# Основная часть программы
print(F(8))


#
#
#
#
#

#Задача(Две функции)
#Алгоритм вычисления значения функций F(n) и G(n), где n — натуральное число, задан следующими соотношениями:
#F(n) = 0, если n <= 2,
#F(n) = G(n - 2), если n > 2
# G(n) = 0, n <= 1,
# G(n) = F(n - 1) + n, если n > 1
# Чему равно значение функции F(8)? В ответе запишите только натуральное число.'

# Сами функции
def F(n):
    if n<=2: return 0
    if n>2: return G(n-2)

def G(n):
    if n<=1: return 0
    if n>1: return F(n-1)+n

# Основная часть программы
print(F(8))




# Задача (Новое веяние)
# (К. Багдасарян) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
# F(n) = 2, если n = 1,
# F(n) = 2 · F(n – 1), если n > 1.
# Чему равно значение выражения F(1900)/2**21890 ?

from functools import lru_cache

# Используем декоратор lru_cache для кэширования результатов функции F(n)
@lru_cache(None)
def F(n):
   # Если n равно 1, то возвращаем 2
   if n == 1:
       return 2
   # Если n больше 1, то возвращаем 2 умноженное на значение функции F(n - 1)
   if n > 1:
       return 2 * F(n - 1)

# Вычисляем значения функции F(n) для всех n от 2 до 1899
for i in range(2, 1900):
   F(i)

# Выводим значение выражения F(1900)/2**21890
print(F(1900) / 2**1890)


#Задача(Новое веяние, закрепление)
# Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
# F(n) = 1 при n ≤ 2;
# F(n) = n * F(n-2), если n > 2.
# Чему равно значение выражение F(3000)/F(2996) ?

from functools import lru_cache

@lru_cache(None)
def F(n):
    if n<=2: return 1
    if n>2: return n*F(n-2)

for i in range(2, 3000):
    F(i)

print(F(3000)/F(2996))

#Задача (Вперёд к победе!)
# Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
# F(n) = 1 при n=1;
# F(n) = 2 при n=2;
# F(n) = n*(n-1) + F(n-1) + F(n-2), если n > 2.
# Чему равно значение функции F(2023) - F(2021) - 2*F(2020) - F(2019)?
from functools import lru_cache

@lru_cache(None)
def F(n):
    if n==1: return 1
    if n==2: return 2
    if n>2: return n*(n-1) + F(n-1) + F(n-2)

for i in range(2, 2023):
    F(i)

print(F(2023) - F(2021) -2*F(2020) - F(2019))


#Задача (Перебираем цикл в обратном порядке)
# Алгоритм вычисления значения функции F(n), где n – натуральное число, за-дан следующими соотношениями:
# F(n) = n при n ≥ 2025;
# F(n) = n + F(n + 2), если n < 2025.
# Чему равно значение выражения F(2020) - F(2023)?

from functools import lru_cache

@lru_cache(None)
def F(n):
    if n>=2025: return n
    if n<2025: return n+F(n+2)

for i in range(2025, 0, -1):
    F(i)

print(F(2020)-F(2023))



#Dополнительные задачи
# Задача (Количество значений
# Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
# F(n) = 2*n*n*n + 1, при n > 25
# F(n) = F(n+2) + 2*F(n+3), при n ≤ 25
# Определите количество натуральных значений n из отрезка [1; 1000], для которых значение F(n) кратно 11.

# Сама функция
def F(n):
    if n>25: return 2*n*n*n + 1
    if n<=25: return F(n+2) + 2*F(n+3)

k=0

# Перебираем диапазон
for i in range(1, 1001):
    if F(i)%11==0:
        k=k+1

print(k)






