# Задача (Разминка)
# В файле содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -10000 до 10000 включительно. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, в которых оба числа делятся нацело на 7, затем минимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два подряд идущих элемента последовательности. 
# Например для последовательности из пяти элементов: 7; 14; 21; -7; 4 - ответ 3 14.

# Открываем файл для чтения
f = open('17_1.txt')

# Инициализируем счетчик количества пар и минимальную сумму
k = 0
mn = 10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   # Читаем следующий элемент последовательности
   n2 = int(s)

   # Если оба числа делятся нацело на 7, то увеличиваем счетчик и обновляем минимальную сумму
   if abs(n1) % 7 == 0 and abs(n2) % 7 == 0:
       k += 1
       mn = min(mn, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и минимальную сумму
print(k, mn)


# Задача (Приём мини-счётчик)
# В файле содержится последовательность целых чисел. 
# Элементы последовательности могут принимать целые значения от -100 000 до 100 000 включительно. 
# Определите количество троек элементов последовательности, в которых хотя бы одно из чисел является четырёхзначным, 
# а сумма элементов тройки больше максимального элемента последовательности, оканчивающегося на 80. В ответе запишите количество найденных троек чисел, 
# затем минимальную из сумм элементов таких троек. В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем переменную mx для поиска максимального числа, оканчивающегося на 80
mx = -10**10

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   # Проверяем, оканчивается ли число на 80
   if abs(x) % 100 == 80:
       # Обновляем максимальное число
       mx = max(mx, x)

# Выводим максимальное число
print(mx)

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем счетчик количества троек и минимальную сумму
k = 0
mn = 10**10

# Читаем первые два элемента последовательности
n1 = int(f.readline())
n2 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n3 = int(s)

   # Приём мини-счётчик
   c = 0
   # Проверяем, является ли число четырёхзначным
   if 1000 <= abs(n1) <= 9999:
       c += 1
   if 1000 <= abs(n2) <= 9999:
       c += 1
   if 1000 <= abs(n3) <= 9999:
       c += 1

   # Основное условие
   if c >= 1 and n1 + n2 + n3 > mx:
       k += 1
       mn = min(mn, n1 + n2 + n3)

   # Обновляем значения предыдущих элементов
   n1 = n2
   n2 = n3

# Выводим количество троек и минимальную сумму
print(k, mn)



# Задача (ЕГЭ по информатике, 2024, остаток от деления)
# В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно.
# Определите количество пар последовательности, в которых остаток от деления на 55 хотя бы одного из элементов равен минимальному элементу последовательности. 
# В ответе запишите количество найденных пар, затем минимальную из сумм элементов таких пар.
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2024_2.txt')

# Инициализируем переменную mn для поиска минимального числа
mn = 10**10

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   # Обновляем минимальное число
   mn = min(mn, x)

# Выводим минимальное число
print(mn)

# Открываем файл для чтения
f = open('17_2024_2.txt')

# Инициализируем счетчик количества пар и минимальную сумму
k = 0
mn = 10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Используем приём мини-счётчик
   c = 0
   # Проверяем, равен ли остаток от деления на 55 минимальному числу
   if n1 % 55 == mn:
       c += 1
   if n2 % 55 == mn:
       c += 1

   # Основное условие
   if c >= 1:
       k += 1
       mn = min(mn, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и минимальную сумму
print(k, mn)




# В файле 17_2.txt содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -100 000 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба числа оканчиваются на одну и ту же нечётную цифру, 
# и при этом хотя бы один элемент пары больше среднего арифметического элементов последовательности. 
# В ответе запишите количество найденных пар, а затем максимальный из модулей разности элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем переменные для подсчета количества элементов и суммы элементов
k = 0
sm = 0

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   k += 1
   sm += x

# Выводим среднее значение
print(sm / k)

#Среднее значение — это сумма элементов, делённая на их количество. Здесь нужно найти среднее значение без каких-либо условий.
#Среднее значение получается 29980.700294117647.
#Перейдём ко второму действию.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем счетчик количества пар и максимальную разность
k = 0
mx = -10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Найдём, на что оканчиваются n1 и n2
   last1 = abs(n1) % 10
   last2 = abs(n2) % 10

   # Основное условие задачи
   if last1 % 2 == 1 and last2 % 2 == 1 and last1 == last2 and (n1 > 29980.700294117647 or n2 > 29980.700294117647):
       k += 1
       mx = max(mx, abs(n2 - n1))

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и максимальную разность
print(k, mx)



# Задача (Полный квадрат)
# В файле содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -10000 до 10000 включительно. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, в которых хотя бы одно число является полным квадратом некоторого натурального числа, 
# затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два подряд идущих элемента последовательности. 
# Например для последовательности из пяти элементов: 9; 15; 23; -3; 4 - ответ 2 24.

# Открываем файл для чтения
f = open('17_3.txt')
# Инициализируем счетчик количества пар и максимальную сумму
k = 0
mx = -10**10
# Читаем первый элемент последовательности
n1 = int(f.readline())
# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Проверяем, является ли хотя бы одно число полным квадратом
   if (n1 > 0 and (round(n1 ** 0.5) ** 2) == n1) or (n2 > 0 and (round(n2 ** 0.5) ** 2) == n2):
       k += 1
       mx = max(mx, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2
# Выводим количество пар и максимальную сумму
print(k, mx)



##Задача (Простое число)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно.
#  Определите количество пар последовательности, в которых хотя бы один элемент больше максимального простого числа в файле. 
# В ответе запишите количество найденных пар, затем минимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

#Решение:
def Pr(n):
    if n==1: return False
    for i in range(2, int(n**0.5)+1):
        if n%i==0:
            return False
    return True

f=open('17_2024_2.txt')

mx=-10**10

for s in f.readlines():
    x=int(s)
    if Pr(x):
        mx=max(mx, x)
print(mx)


#Простое число — это такое число, которое имеет ровно 2 различных делителя: единицу и само это число. 
# Функция Pr(n) проверят на простоту число n. Внутри функции пробегаемся с 2 до корня исследуемого числа. 
# Если хотя бы встретится один делитель в этом диапазоне, то число не простое и функция возвращает False. 
# В противном случае, возвращаем True. Почему достаточно идти до корня числа? - Читайте в статье по 25 Заданию.
#Единица не является простым числом.
#Получается число 99721.


f=open('17_2024_2.txt')

k=0
mn=10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 99721 or n2 > 99721:
        k += 1
        mn = min(mn, n1+n2)
    n1=n2

print(k, mn)



#Задача (Другая система счисления)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба элемента больше минимального числа во всей последовательности, которое в семеричной системе оканчивается на 3. 
# В ответе запишите количество найденных пар, затем максимальную сумму квадратов элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

#Решение:
#Первым действием найдём минимальное число во всей последовательности, которое в семеричной системе оканчивается на 3.


f=open('17_2024_2.txt')

mn=10**10

for s in f.readlines():
    x=int(s)
    if x%7==3:
        mn=min(mn, x)
print(mn)

#Первый остаток при делении на 7 — это и есть последняя цифра в семеричной системе. Об это мы говорили в 14 Задании.
#Получается число 87.


f=open('17_2024_2.txt')

k=0
mx=-10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 87 and n2 > 87:
        k += 1
        mx = max(mx, n1**2 + n2**2)
    n1=n2

print(k, mx)




#Задача (Проверить первую цифру)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба элемента больше максимального числа во всей последовательности, 
# которое начинается на цифру "1". В ответе запишите количество найденных пар, затем минимальную сумму элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.



#Решение:
#Первым действием найдём максимальное число во всей последовательности, которое начинается на цифру "1".


f=open('17_2024_2.txt')

mx=-10**10

for s in f.readlines():
    x = int(s)
    if str(x)[0] == '1':
        mx=max(mx, x)

print(mx)




#Получается число 19989. Здесь с помощью функции str() преобразовываем число x в строку и анализируем первый символ этой строки. 
# Если он равен символу "1", то это число допускаем до "Царя горы".


f=open('17_2024_2.txt')

k=0
mn=10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 19989 and n2 > 19989:
        k += 1
        mn = min(mn, n1+n2)
    n1=n2

print(k, mn)


#Задача (Числа расположены в порядке возрастания)
#В файле 17-3.txt содержится последовательность целых чисел. 
# Элементы последовательности могут принимать целые значения от -10 000 до 10 000 включительно.
#  Определите и запишите в ответе сначала количество троек элементов последовательности, в которых числа расположены в порядке возрастания, 
# затем минимальную из разностей наибольшего и наименьшего элементов таких троек. 
# В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.



#Решение:
f=open('17-3.txt')

k=0
rz=10**10

n1=int(f.readline())
n2=int(f.readline())

for s in f.readlines():
    n3 = int(s)

    if n1 < n2 < n3:
        k += 1
        mx = max(n1, n2, n3)
        mn = min(n1, n2, n3)
        rz = min(rz, mx-mn)

    n1=n2
    n2=n3


print(k, rz)




#Задача (Любой порядок элементов)
#В файле содержится последовательность из 10 000 целых положительных чисел. Каждое число не превышает 10 000. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, у которых сумма элементов кратна 9, затем максимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два различных элемента последовательности. 
# Порядок элементов в паре не важен.

#Решение:

#Первый способ (Красивый).

f = open('17.txt')

count_0 = 0
count_1 = 0
count_2 = 0
count_3 = 0
count_4 = 0
count_5 = 0
count_6 = 0
count_7 = 0
count_8 = 0


mx1_0 = 0
mx2_0 = 0
mx_1 = 0
mx_2 = 0
mx_3 = 0
mx_4 = 0
mx_5 = 0
mx_6 = 0
mx_7 = 0
mx_8 = 0


for s in f.readlines():
    n=int(s)

    if n%9==0:
        count_0 = count_0 + 1

        if n>mx1_0:
            if n>mx2_0:
                mx1_0 = mx2_0
                mx2_0 = n
            else:
                mx1_0 = n

    if n%9==1:
        count_1 = count_1 + 1
        mx_1 = max(mx_1, n)

    if n%9==2:
        count_2 = count_2 + 1
        mx_2 = max(mx_2, n)

    if n%9==3:
        count_3 = count_3 + 1
        mx_3 = max(mx_3, n)

    if n%9==4:
        count_4 = count_4 + 1
        mx_4 = max(mx_4, n)

    if n%9==5:
        count_5 = count_5 + 1
        mx_5 = max(mx_5, n)

    if n%9==6:
        count_6 = count_6 + 1
        mx_6 = max(mx_6, n)

    if n%9==7:
        count_7 = count_7 + 1
        mx_7 = max(mx_7, n)

    if n%9==8:
        count_8 = count_8 + 1
        mx_8 = max(mx_8, n)


count = (count_1*count_8) + (count_2*count_7)  + (count_3*count_6) + (count_4*count_5) + (count_0*(count_0-1)//2)
mx = max(mx_1 + mx_8, mx_2 + mx_7, mx_3 + mx_6, mx_4 + mx_5, mx1_0 + mx2_0)

print(count, mx)




#Здесь мы ищем количество элементов, у которых остаток при делении на 9 равен нулю, единице, двойке, ... и до 8. Подсчитываем эти данные соответственно в переменные count_0, count_1, count_2 ... и т.д.


#Так же находим максимальное число, которое имеет при делении на 9 остаток равный единице, двойке, ... и т.д. Для чисел, которые имеют остаток при делении на 9 ноль, находим два максимальных числа.


#После того, как результаты находятся в нужных переменных, можно вычислить ответ к задаче.


#Если, к примеру, взять число для которого остаток равен 1 и число для которого остаток равен 8, то их сумма будет делится на 9. Найдём количество пар, если нам известно количество и тех, и тех чисел.


#ЕГЭ по информатике 2022 - задание 17 (Числа не по порядку)

#Значит, просто нужно перемножить два числа, к примеру, count_1*count_8.


#Для чисел, которые делятся на 9 (т.е. остаток равен нулю), количество пар считается немного по-другому. Такие числа можно суммировать между собой, всё равно сумма тоже будет делится на 9. Путь есть у нас количество чисел count_0, которые делятся на 9. Тогда найдём количество пар, которые можно составить из этих элементов.


#Здесь вспомним метод умножения, о котором было написано в этой статье.


#ЕГЭ по информатике 2022 - задание 17 (Числа не по порядку)

#Найдём количество таких пар, если каждый элемент можно использовать 1 раз. Получается count_0*(count_0-1). Но т.к. в нашем случае пара, когда элементы находятся в одном порядке и в обратном, является одной и той же, то нужно это количество поделить на 2. Т.е количество пар будет (count_0*(count_0-1))/2.





#Второй способ (Перебор).

f = open('17.txt')

count=0
mx=0

a = []

#Считываем все числа в массив a
for s in f.readlines():
    n = int(s)
    a.append(n)

# Перебираем все варианты и подсчитываем пары, отвечающие условию задачи.
for i in range(0, len(a)):
    for j in range(i+1, len(a)):
        if (a[i]+a[j])%9==0:
            count = count + 1
            mx = max(a[i]+a[j], mx)
    

print(count, mx)

#В этом решении сначала считываем все числа в массив a.
#Далее берём число и начинаем его комбинировать со всеми числами, которые стоят после этого числа. 
#Таким образом, мы переберём все возможные комбинации, и у нас не будут пары повторяться.





