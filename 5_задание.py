###Запись переворачиваеться
for n in range(1001):
    s = bin(n)[2:]
    if int(s[::-1], 2)==23:
        print(n)

###Справо дописываются два разряда: символы 01, если число n чётное, и 10 если нечётное

for n in range(1001):
    s = bin(n)[2:]
    if n % 2==0:
        s +='01'
    else:
        s+='10'
    if int(s,2)>138:
        print(n)
        break # потому что нужно указать минимальное число N


res = []
for n in range(1001):
    s = bin(n)[2:]
    s += str(s.count('1')%2) # складываються все цифры двоичной записи, остаток от деления суммы на 2 дописываеться в конец числа
    s += str(s.count('1') % 2) # тоже самое действие
    if int(s,2)>118:
        res.append(int(s,2)) # если нужно найти наименьшее число R. Добавляем в список и переводим в десятичную запись
print(min(res))


res = []
for n in range(1001):
    s = bin(n)[2:]
    if n %3 == 0:
        s +=s [-2:] # Берём число с конца, предпоследний и до конца. Например из числа 1001011 берём 11 и дописываем в конец
    else:
        s+=bin(n%3*3)[2:] # Остаток от деления умножаеться на 3 и переводиться в двоичную систему и дописываеться в конец числа
    if int(s, 2)>=195:
        res.append(int(s,2))
print(min(res)) # Потому что опять нужно найти минамальное число R


for n in range(10001):
    s = bin(n)[2:]
    s+=bin(7)[2:] if n %7 == 0 else '1' # К s дописываем двоичный код числа 7, если делиться на 7, если не делиться дописываем 1
    #можно по другому
    # if n%7==0:
    #     s+=bin(7)[2:]
    # else:
    #     s+='1'
    i = int(s,2) # делаем новую переменную и переводим в 10-ную систему
    s += bin(5)[2:] if i % 5 == 0 else '1' # К s дописываем двоичный код числа 5, если делиться на 5, если не делиться дописываем 1
    if int(s,2)>500000: # Число R больше 500000
        print(n) # Потому что наименьшее N, ничего больше не надо, они идут по порядку
        break # если в результате нет ответа и не вышла ошибка, нужно увеличить диапазон range(10000)

def f(n): #Создаём функциию для перевода в 12-ти-ричную систему
    stroka = '0123456789AB' # Строка с числами которые можут в быть в 12-ти-ричной системе
    if n<12: return stroka[n] #возращаем элемент. Если n=5, вернём 5
    return f(n//12)+stroka[n%12] #если условие не выполнено, передаём функцию кроме последней цифры  12-ти-ричной записи числа + последняя цифра 12-ти-ричной записи числа
res = []
for n in range(144, 1000): # условие задачи, N должно быть больше 143, счёт начинаем с 144
    s = f(n)
    if n %12==0: s+=s[-3:]
    else: s = f(n % 12 * 3) + s # остаток от деления умножаеться на 3, переводиться в 12-ти-ричную запись и дописываеться в начало числа
    if int(s,12)<58000:
        res.append((int(s,12), n)) # первый элемент, результат работы, второй число N
print(sorted(res, reverse=True)[0]) #сортируем список по убыванию, т.к нужно наибольшее значение, выводим элемент с индексом ноль, тоесть самый первый и самый большой Получаем R и N

summa = 0
for n in range(10000,100000): # Пятизначное натуральное число, последнее 999999
    s = oct(n)[2:] # Перевод в восмиричную запись числа
    for _ in range(2): # повторяем всё это 2 раза
        for c in '1357': s = s.replace(c, '2') # Все нечётные цифры, а в восмиричной это 1357, заменяються на 2, функциия replac
        s+= str(n%8) # к строке дописывается остаток от деления на 8
    if int(s,8)%2023 ==0: # переводим из восмиричной в десятичную, проверяем чтобы число делилось на 2023, если делиться к summe т.е к нулю, добовляем n и в ответе получаем сумму всех таких чисел
        summa +=n
print(summa)


####################################################################
################################################################
###################################################################
######################################################################
#############################################################
###############################################################
###################################################################
##############################################################
#####################################################################
#######################################################################
#######################################################################

#Курс, ещё практика########################
#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
# Укажите такое наименьшее число N, для которого результат работы данного алгоритма больше числа 170. 
# В ответе это число запишите в десятичной системе счисления.

for n in range(1000):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)>170:
        print(n)
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Какое наибольшее число, меньшее 50, может быть получено в результате работы автомата?


for n in range(1000, 0 , -1):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)<50:
        print(int(s,2))
        break

# or 
for n in range(1000, 0, -1):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)<50:
        print(int(s,2))
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2)
#К этой записи дописывается (дублируется) последняя цифра.
#3) Затем справа дописывается 0, если в двоичном коде числа N чётное число единиц, и 1, если нечётное.
#4) К полученному результату дописывается ещё один бит чётности так, чтобы количество единиц в двоичной записи полученного числа стало чётным.
#Полученная таким образом запись (в ней на три разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число R, большее 130, которое могло получиться в результате работы автомата. 
#В ответе это число запишите в десятичной системе.
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += s[-1]
    s += str(bin(n).count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)>130:
        res.append(int(s,2))

print(min(res))

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Сколько различных чисел, принадлежащих отрезку [210; 260], могут появиться на экране в результате работы автомата?
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if 210<=int(s,2)<=260:
        res.append(int(s,2))
print(len(res))


#Автомат обрабатывает натуральное число N по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) Запись «переворачивается», то есть читается справа налево. Если при этом появляются ведущие нули, они отбрасываются.
#3) Полученное число переводится в десятичную систему счисления и выводится на экран.
#Какое наибольшее число, не превышающее 500, после обработки автоматом даёт результат 13?

for n in range(500, 0, -1):
    s = bin(n)[2:]
    if int(s[::-1], 2) == 13:
        print(n)
        break

#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#4) Из нового числа вычитается исходное, полученная разность выводится на экран.
#Для какого значения N результат работы алгоритма равен 45?
for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    for i in s:
        if i == '1' :
            s1+='0'
        else:
            s1+='1'
    if int(s1,2)-n==45:
        print(n)


#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа, кроме последней единицы и стоящих за ней нулей (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#ля какого значения N результат работы алгоритма равен 193?

for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    i1 = s.rindex('1')
    for i in range(i1):
        if s[i] == '1': s1 += '0'
        else: s1+='1'
    s1+=s[i1:]
    if int(s,2)==193:
        print(n)


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2) Затем справа дописываются два разряда: символы 01, если число N чётное, и 10, если нечётное.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число N, после обработки которого автомат получает число, большее 138. 
#В ответе это число запишите в десятичной системе.

for n in range(1000):
    s = bin(n)[2:]
    if n % 2 == 0: s+='01'
    else: s+='10'
    if int(s, 2)>138:
        print(n)
        break

#Автомат обрабатывает натуральное число N > 1 по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) В конец записи (справа) дописывается вторая справа цифра двоичной записи.
#3) В конец записи (справа) дописывается вторая слева цифра двоичной записи.
#4) Результат переводится в десятичную систему. Пример. Дано число N = 11. Алгоритм работает следующим образом.
#Для скольких значений N в результате работы алгоритма получится число, принадлежащее отрезку [150; 200]?
k = 0
for n in range(2, 1000):
    s = bin(n)[2:]
    s += s[-2] + s[1]
    if 150 <= int(s, 2) <= 200:
        k += 1
print(k)


#Автомат обрабатывает десятичное натуральное число N по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) К полученному числу справа дописывается 0, если в числе сдиниц больше, чем нулей; иначе дописывается 1.
#3) Из середины двоичного числа убирается 2 разряда, если количество разрядов получилось четным, и 3 разряда, если нечетное.
#4) Результат переводится в десятичную систему. Пример. Дано число N = 11. Алгоритм работает следующим образом.
#1) Двоичная запись числа N: 11 = 10112
#2) Единиц больше, чем нулей, новая запись 101102.
#3)
#Длина начётная, удаляем три средних разряда, новая запись 102.
#4) Десятичное значение полученного числа 2.
#Для скольких различных значений N в результате работы автомата получается число 58?
k = 0
for n in range(4,100000):
    s = bin(n)[2:]
    if s.count('1') > s.count('0'):
         s+='0'
    else: s += '1'
    m = len(s)//2
    if len(s)%2 ==0:
        s = s[:m-1] + s[m+1:]
    else: s = s[:m-1] + s[m+2:]
    if int(s, 2)==58:
        k+=1
print(k)

#Алгоритм получает на вход натуральное число N > 1 и строит по нему новое число R следующим образом:
#1) Строится двоичная запись числа N.
#2) Подсчитывается количество нулей и единиц в полученной записи. Если их количество одинаково, в конец записи добавляется её последняя цифра. В противном случае в конец записи добавляется цифра, которая встречается реже.
#3) Шаг 2 повторяется сщё два раза.
#4) Результат переводится в десятичную систему счисления.
#При каком наименьшем исходном числе N > 80 в результате работы алгоритма получится число, кратное 4?

for n in range(81, 1000):
    s = bin(n)[2:]
    if s.count("1")== s.count("0"):
        s += s[-1]
    else:
        if s.count("1") > s.count("0"):
            s+='0'
        else:
            s+='1'
    if s.count("1")== s.count("0"):
        s += s[-1]
    else:
        if s.count("1") > s.count("0"):
            s+='0'
        else:
            s+='1'
    if int(s, 2)%4==0:
        print(n)
        break
        
#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2)
#К этой записи дописываются ещё несколько разрядов по следующему
#правилу:
#a) если N чётное, то к нему справа приписывается в двоичном виде сумма цифр его двоичной записи;
#б) если N нечётное, то к нему справа приписываются два нуля, а слева единица. Например, двоичная запись числа 1101 будет преобразована в 1110100.
#Полученная таким образом запись (в ней как минимум на один разряд больше, чем в записи исходного числа N) является двоичной записью искомого числа R.
#Укажите наименьшее число N, для которого результат работы данного алгоритма больше 215. В ответе это число запишите в десятичной системе счисления. 

for n in range(1, 10000):
    s = bin(n)[2:]
    if n%2==0:
        s += bin(s.count('1'))[2:]
    else:
        s = '1' + s + '00'
    if int(s, 2)>215:
        print(n)
        break


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) если сумма цифр двоичной записи чётная, то к этой записи справа дописывается 0, а два левых разряда заменяются на 10;
#б) если сумма цифр двоичной записи нечётная, то к этой записи справа дописывается 1, а два левых разряда заменяются на 11.
#Полученная таким образом запись является двоичной записью искомого числа R.
#Например, для исходного числа 6 = 1102 результатом является 10002 = 8, а для исходного числа 4 = 1002 результатом является 11012 = 13. 
#Укажите минимальное число N, после обработки которого с помощью этого алгоритма получается число R, большее 50. 
# В ответе запишите это число в десятичной системе счисления.

for n in range(1, 10000):
    s = bin(n)[2:]
    if s.count('1')%2==0:
        s = '10' + s[:-2] + '0'
    else:
        s = '11' + s[:-2] + '1'


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) если число N делится на 3, то к этой записи дописываются три последние двоичные цифры;
#б) если число N на 3 не делится, то остаток от деления умножается на
#3, переводится в двоичную запись и дописывается в конец числа. Полученная таким образом запись является двоичной записью искомого числа R.
#3. Результат переводится в десятичную систему и выводится на экран. Например, для исходного числа 12 = 11002 результатом является число 11001002 = 100, а для исходного числа 4 = 1002 это число 100112 = 19.
#Укажите минимальное число R, большее 151, которое может быть получено с помощью описанного алгоритма. В ответе запишите это число в десятичной системе счисления.

res = []
for n in range(1, 1000):
    s = bin(n)[2:]
    if n%3==0:
        s += s[-3:]
    else:
        s += bin(n%3*3)[2:]
    if int(s, 2)>151:
        res.append(int(s, 2))
print(min(res))

#*На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом:
#1. Строится двоичная запись числа N.
#2. Если число N делится на 3, в конец двоичной записи дописывается двоичный код числа 3, иначе дописывается единица.
#3. Если число, полученное после шага 2, делится на 5, в конец двоичной записи дописывается двоичный код числа 5, иначе дописывается единица.
#4. Полученная таким образом запись является двоичной записью искомого числа
#R.
#Например, для исходного числа 710 = 1112 (не делится на 3) после шага 2 получается число 11112 = 1510 (делится на 5), а после шага 3 - число 11111012
#=
#12510. Определите наибольшее возможное значение N, для которого в результате работы алгоритма получается R < 106.
for n in range(10000,0,-1):
    s = bin(n)[2:]
    s+= bin(3)[2:] if n%3==0 else '1'
    i = int(s, 2)
    s+= bin(5)[2:] if i%5==0 else '1'
    if int(s, 2)<10**6:
        print(n)
        break

#(PRO100-EГЭ) На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится троичная запись числа N.
#2. К этой записи дописываются справа ещё несколько разрядов по следующему
#правилу:
#a)
#если N чётное, то к нему справа приписываются два нуля, а слева
#единица;
#б) если N нечётное, то к нему справа приписывается в троичном виде сумма цифр его троичной записи.
#Полученная таким образом запись (в ней как минимум на один разряд больше, чем в записи исходного числа N) является троичной записью искомого числа R.
#Например, исходное число 410 = 113 преобразуется в число 111003 = 11710, а исходное число 710 = 213 преобразуется в число 21103 = 6610-
#Укажите такое наименьшее число N, для которого число R больше числа 168. 
# В ответе запишите это число в десятичной системе счисления.

def theree(x):
    res = ''
    while x:
        res+=str(x%3)
        x//=3
    return res[::-1]
for n in range(1,10000):
    s = theree(n)
    if n%2==0:
        s = '1'+s+'00'
    else:
        s += theree(sum(map(int,s)))
    if int(s,3)>168:
        print(n)
        break

#*(П. инкель) На вход алгоритма подаётся пятизначное натуральное число N. Алгоритм строит по нему новое число R следующим образом:
#1. Число N переводится в двадцатеричную систему счисления.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) гласные буквы (А, Е, I) заменяются на 1;
#б) в конец полученной записи дописывается остаток от деления числа N на 20 в двадцатеричной системе счисления;
#b) первая цифра переставляется в конец записи.
#3. Действия а)-в) в п. 2. повторяются еще раз.
#Полученная таким образом запись является записью искомого числа R в двадцатеричной системе счисления. 
#Укажите максимальное число R, кратное 2030, которое может быть получено в результате работы алгоритма. 
#Запишите его в ответе в десятичной системе счисления.
res = []
def f(x):
    stroka = '0123456789ABCDEFGHI'
    if x < 20: return stroka[x]
    return f(x//20)+stroka[x%20]
for n in range(10**4, 10**5):
    s = f(n)
    s = s.replace('A','1').replace('E','1').replace('I','1')
    s+= f(n%20)
    s = s[1:]+s[0]
    s = s.replace('A','1').replace('E','1').replace('I','1')
    s+= f(n%20)
    s = s[1:]+s[0]
    if int(s,20)%2030==0:
        res.append(int(s,20))
print(max(res))

#Автомат получает на вход пятизначное число. По этому числу строится новое число по следующим правилам.
#1. Складываются отдельно первая, третья и пятая цифры, а также вторая и четвёртая цифры.
#2. Полученные два числа записываются друг за другом в порядке неубывания без разделителей.
#Пример. Исходное число: 63 179. Суммы: 6 + 1 + 9 = 16; 3 + 7 = 10. Результат: 1016. Укажите наименьшее число, при обработке которого автомат выдаёт результат 723.

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Вычисляется сумма S1 всех нечётных цифр десятичной записи числа N. Если нечётных цифр нет, сумма S1 считается равной 0.
#2) Вычисляется сумма S2 всех цифр десятичной записи числа N, стоящих в чётных разрядах. Разряды нумеруются справа налево, начиная с 0.
#3) Вычисляется результат R как модуль разности S1 и S2.
#Например, N = 1234. Сумма нечётных цифр S1 = 1 + 3 - 4. Сумма цифр в чётных разрядах S2 = 2 + 4 = 6. Результат работы алгоритма R = 6 4 = 2.
#Укажите наименьшее число, в результате обработки которого по данному алгоритму получится число 29.
for n in range(1, 10000):
    s = str(n)[::-1]
    s1 = sum(int(i)for i in s if i in '13579')
    s2 = sum(int([i])for i in range(0,len(s),2))
    if abs(s1-s2)==29:
        print(n)
        break

#Автомат получает на вход трёхзначное число. По этому числу строится новое число по следующим правилам.
#1. Из цифр, образующих десятичную запись N, строятся наибольшее и наименьшее возможные двузначные числа (числа не могут начинаться с нуля).
#2. На экран выводится разность полученных двузначных чисел. Пример. Дано число N = 351. Наибольшее двузначное число из заданных цифр
#53, наименьшее - 13. На экран выводится разность 53 - 13 = 40.
#Чему равно количество чисел N на отрезке [300; 400], в результате обработки которых на экране автомата появится число 20?
k= 0
for n in range(300,401):
    s = sorted(str(n))
    if s[0]=='0':
        if s[1] ==  '0':
            maxim = minim = int(s[2]+'0')
        else:
            minim = int(s[1]+ '0')
            maxim = int(s[2]+s[1])
    else:
        minim = int(s[0]+s[1])
        maxim = int(s[2]+s[1])
    if maxim-minim == 20:
        k+=1
print(k)