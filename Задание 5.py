###Запись переворачиваеться
for n in range(1001):
    s = bin(n)[2:]
    if int(s[::-1], 2)==23:
        print(n)

###Справо дописываются два разряда: символы 01, если число n чётное, и 10 если нечётное

for n in range(1001):
    s = bin(n)[2:]
    if n % 2==0:
        s +='01'
    else:
        s+='10'
    if int(s,2)>138:
        print(n)
        break # потому что нужно указать минимальное число N


res = []
for n in range(1001):
    s = bin(n)[2:]
    s += str(s.count('1')%2) # складываються все цифры двоичной записи, остаток от деления суммы на 2 дописываеться в конец числа
    s += str(s.count('1') % 2) # тоже самое действие
    if int(s,2)>118:
        res.append(int(s,2)) # если нужно найти наименьшее число R. Добавляем в список и переводим в десятичную запись
print(min(res))


res = []
for n in range(1001):
    s = bin(n)[2:]
    if n %3 == 0:
        s +=s [-2:] # Берём число с конца, предпоследний и до конца. Например из числа 1001011 берём 11 и дописываем в конец
    else:
        s+=bin(n%3*3)[2:] # Остаток от деления умножаеться на 3 и переводиться в двоичную систему и дописываеться в конец числа
    if int(s, 2)>=195:
        res.append(int(s,2))
print(min(res)) # Потому что опять нужно найти минамальное число R


for n in range(10001):
    s = bin(n)[2:]
    s+=bin(7)[2:] if n %7 == 0 else '1' # К s дописываем двоичный код числа 7, если делиться на 7, если не делиться дописываем 1
    #можно по другому
    # if n%7==0:
    #     s+=bin(7)[2:]
    # else:
    #     s+='1'
    i = int(s,2) # делаем новую переменную и переводим в 10-ную систему
    s += bin(5)[2:] if i % 5 == 0 else '1' # К s дописываем двоичный код числа 5, если делиться на 5, если не делиться дописываем 1
    if int(s,2)>500000: # Число R больше 500000
        print(n) # Потому что наименьшее N, ничего больше не надо, они идут по порядку
        break # если в результате нет ответа и не вышла ошибка, нужно увеличить диапазон range(10000)

def f(n): #Создаём функциию для перевода в 12-ти-ричную систему
    stroka = '0123456789AB' # Строка с числами которые можут в быть в 12-ти-ричной системе
    if n<12: return stroka[n] #возращаем элемент. Если n=5, вернём 5
    return f(n//12)+stroka[n%12] #если условие не выполнено, передаём функцию кроме последней цифры  12-ти-ричной записи числа + последняя цифра 12-ти-ричной записи числа
res = []
for n in range(144, 1000): # условие задачи, N должно быть больше 143, счёт начинаем с 144
    s = f(n)
    if n %12==0: s+=s[-3:]
    else: s = f(n % 12 * 3) + s # остаток от деления умножаеться на 3, переводиться в 12-ти-ричную запись и дописываеться в начало числа
    if int(s,12)<58000:
        res.append((int(s,12), n)) # первый элемент, результат работы, второй число N
print(sorted(res, reverse=True)[0]) #сортируем список по убыванию, т.к нужно наибольшее значение, выводим элемент с индексом ноль, тоесть самый первый и самый большой Получаем R и N

summa = 0
for n in range(10000,100000): # Пятизначное натуральное число, последнее 999999
    s = oct(n)[2:] # Перевод в восмиричную запись числа
    for _ in range(2): # повторяем всё это 2 раза
        for c in '1357': s = s.replace(c, '2') # Все нечётные цифры, а в восмиричной это 1357, заменяються на 2, функциия replac
        s+= str(n%8) # к строке дописывается остаток от деления на 8
    if int(s,8)%2023 ==0: # переводим из восмиричной в десятичную, проверяем чтобы число делилось на 2023, если делиться к summe т.е к нулю, добовляем n и в ответе получаем сумму всех таких чисел
        summa +=n
print(summa)

#####Практика____________________________________________________________________________

res =[]
for n in range(1000):
    s = bin(n)[2:]
    if s.count('1') %2==0:
        s+='11'
    else:
        s+='01'
    if int(s,2)>61:
        res.append(int(s,2))
print(min(res))
res =[]
for n in range(1000):
    s = bin(n)[2:]
    if n%3==0:
        s ='1'+ s
        s = s[:-2] +'11'
    else:
        s+='10'+s+'0'
    if int(s,2) >999 and n %2 ==0:
        res.append(int(s,2))
print(min(res))
####################################################################
################################################################
###################################################################
######################################################################
#############################################################
###############################################################
###################################################################
##############################################################
#####################################################################
#######################################################################
#######################################################################

#Курс, ещё практика########################
#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
# Укажите такое наименьшее число N, для которого результат работы данного алгоритма больше числа 170. 
# В ответе это число запишите в десятичной системе счисления.

for n in range(1000):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)>170:
        print(n)
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Какое наибольшее число, меньшее 50, может быть получено в результате работы автомата?


for n in range(1000, 0 , -1):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)<50:
        print(int(s,2))
        break

# or 
for n in range(1000, 0, -1):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)<50:
        print(int(s,2))
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2)
#К этой записи дописывается (дублируется) последняя цифра.
#3) Затем справа дописывается 0, если в двоичном коде числа N чётное число единиц, и 1, если нечётное.
#4) К полученному результату дописывается ещё один бит чётности так, чтобы количество единиц в двоичной записи полученного числа стало чётным.
#Полученная таким образом запись (в ней на три разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число R, большее 130, которое могло получиться в результате работы автомата. 
#В ответе это число запишите в десятичной системе.
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += s[-1]
    s += str(bin(n).count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)>130:
        res.append(int(s,2))

print(min(res))

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Сколько различных чисел, принадлежащих отрезку [210; 260], могут появиться на экране в результате работы автомата?
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if 210<=int(s,2)<=260:
        res.append(int(s,2))
print(len(res))


#Автомат обрабатывает натуральное число N по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) Запись «переворачивается», то есть читается справа налево. Если при этом появляются ведущие нули, они отбрасываются.
#3) Полученное число переводится в десятичную систему счисления и выводится на экран.
#Какое наибольшее число, не превышающее 500, после обработки автоматом даёт результат 13?

for n in range(500, 0, -1):
    s = bin(n)[2:]
    if int(s[::-1], 2) == 13:
        print(n)
        break

#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#4) Из нового числа вычитается исходное, полученная разность выводится на экран.
#Для какого значения N результат работы алгоритма равен 45?
for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    for i in s:
        if i == '1' :
            s1+='0'
        else:
            s1+='1'
    if int(s1,2)-n==45:
        print(n)


#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа, кроме последней единицы и стоящих за ней нулей (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#ля какого значения N результат работы алгоритма равен 193?

for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    i1 = s.rindex('1')
    for i in range(i1):
        if s[i] == '1': s1 += '0'
        else: s1+='1'
    s1+=s[i1:]
    if int(s,2)==193:
        print(n)


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2) Затем справа дописываются два разряда: символы 01, если число N чётное, и 10, если нечётное.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число N, после обработки которого автомат получает число, большее 138. 
#В ответе это число запишите в десятичной системе.

for n in range(1000):
    s = bin(n)[2:]
    if n % 2 == 0: s+='01'
    else: s+='10'
    if int(s, 2)>138:
        print(n)
        break

#Автомат обрабатывает натуральное число N > 1 по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) В конец записи (справа) дописывается вторая справа цифра двоичной записи.
#3) В конец записи (справа) дописывается вторая слева цифра двоичной записи.
#4) Результат переводится в десятичную систему. Пример. Дано число N = 11. Алгоритм работает следующим образом.
#Для скольких значений N в результате работы алгоритма получится число, принадлежащее отрезку [150; 200]?
k = 0
for n in range(2, 1000):
    s = bin(n)[2:]
    s += s[-2] + s[1]
    if 150 <= int(s, 2) <= 200:
        k += 1
print(k)

