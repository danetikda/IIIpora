#Это файл со всеми типами решений задачь ЕГЭ по информатике

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________


# 2 задание Егэ по иноформатике
print("x y z w")
for x in range(0, 2):
    for y in range(0, 2):
        for z in range(0, 2):
            for w in range(0, 2):
                if not((x == (w or y)) or ((w <= z) and (y <= w))):
                    print(x, y, z, w)

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________


#3 задание Егэ по информатике основные формулы
# ВПР(Искомое_значение; Диапазон_таблицы; Номер_столбца; [Тип_совпадения])
# =ВПР(D2; Товар!A:F; 3; ЛОЖЬ)


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

# 5 Задание Егэ по информатике
###Запись переворачиваеться
for n in range(1001):
    s = bin(n)[2:]
    if int(s[::-1], 2)==23:
        print(n)

###Справо дописываются два разряда: символы 01, если число n чётное, и 10 если нечётное

for n in range(1001):
    s = bin(n)[2:]
    if n % 2==0:
        s +='01'
    else:
        s+='10'
    if int(s,2)>138:
        print(n)
        break # потому что нужно указать минимальное число N


res = []
for n in range(1001):
    s = bin(n)[2:]
    s += str(s.count('1')%2) # складываються все цифры двоичной записи, остаток от деления суммы на 2 дописываеться в конец числа
    s += str(s.count('1') % 2) # тоже самое действие
    if int(s,2)>118:
        res.append(int(s,2)) # если нужно найти наименьшее число R. Добавляем в список и переводим в десятичную запись
print(min(res))


res = []
for n in range(1001):
    s = bin(n)[2:]
    if n %3 == 0:
        s +=s [-2:] # Берём число с конца, предпоследний и до конца. Например из числа 1001011 берём 11 и дописываем в конец
    else:
        s+=bin(n%3*3)[2:] # Остаток от деления умножаеться на 3 и переводиться в двоичную систему и дописываеться в конец числа
    if int(s, 2)>=195:
        res.append(int(s,2))
print(min(res)) # Потому что опять нужно найти минамальное число R


for n in range(10001):
    s = bin(n)[2:]
    s+=bin(7)[2:] if n %7 == 0 else '1' # К s дописываем двоичный код числа 7, если делиться на 7, если не делиться дописываем 1
    #можно по другому
    # if n%7==0:
    #     s+=bin(7)[2:]
    # else:
    #     s+='1'
    i = int(s,2) # делаем новую переменную и переводим в 10-ную систему
    s += bin(5)[2:] if i % 5 == 0 else '1' # К s дописываем двоичный код числа 5, если делиться на 5, если не делиться дописываем 1
    if int(s,2)>500000: # Число R больше 500000
        print(n) # Потому что наименьшее N, ничего больше не надо, они идут по порядку
        break # если в результате нет ответа и не вышла ошибка, нужно увеличить диапазон range(10000)

def f(n): #Создаём функциию для перевода в 12-ти-ричную систему
    stroka = '0123456789AB' # Строка с числами которые можут в быть в 12-ти-ричной системе
    if n<12: return stroka[n] #возращаем элемент. Если n=5, вернём 5
    return f(n//12)+stroka[n%12] #если условие не выполнено, передаём функцию кроме последней цифры  12-ти-ричной записи числа + последняя цифра 12-ти-ричной записи числа
res = []
for n in range(144, 1000): # условие задачи, N должно быть больше 143, счёт начинаем с 144
    s = f(n)
    if n %12==0: s+=s[-3:]
    else: s = f(n % 12 * 3) + s # остаток от деления умножаеться на 3, переводиться в 12-ти-ричную запись и дописываеться в начало числа
    if int(s,12)<58000:
        res.append((int(s,12), n)) # первый элемент, результат работы, второй число N
print(sorted(res, reverse=True)[0]) #сортируем список по убыванию, т.к нужно наибольшее значение, выводим элемент с индексом ноль, тоесть самый первый и самый большой Получаем R и N

summa = 0
for n in range(10000,100000): # Пятизначное натуральное число, последнее 999999
    s = oct(n)[2:] # Перевод в восмиричную запись числа
    for _ in range(2): # повторяем всё это 2 раза
        for c in '1357': s = s.replace(c, '2') # Все нечётные цифры, а в восмиричной это 1357, заменяються на 2, функциия replac
        s+= str(n%8) # к строке дописывается остаток от деления на 8
    if int(s,8)%2023 ==0: # переводим из восмиричной в десятичную, проверяем чтобы число делилось на 2023, если делиться к summe т.е к нулю, добовляем n и в ответе получаем сумму всех таких чисел
        summa +=n
print(summa)


####################################################################
################################################################

#Курс
#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
# Укажите такое наименьшее число N, для которого результат работы данного алгоритма больше числа 170. 
# В ответе это число запишите в десятичной системе счисления.

for n in range(1000):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)>170:
        print(n)
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Какое наибольшее число, меньшее 50, может быть получено в результате работы автомата?


for n in range(1000, 0 , -1):
    s = bin(n)[2:]
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if s.count('1') %2==0: s+='0'
    else: s+='1'
    if int(s,2)<50:
        print(int(s,2))
        break

# or 
for n in range(1000, 0, -1):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)<50:
        print(int(s,2))
        break

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2)
#К этой записи дописывается (дублируется) последняя цифра.
#3) Затем справа дописывается 0, если в двоичном коде числа N чётное число единиц, и 1, если нечётное.
#4) К полученному результату дописывается ещё один бит чётности так, чтобы количество единиц в двоичной записи полученного числа стало чётным.
#Полученная таким образом запись (в ней на три разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число R, большее 130, которое могло получиться в результате работы автомата. 
#В ответе это число запишите в десятичной системе.
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += s[-1]
    s += str(bin(n).count('1')%2)
    s += str(s.count('1')%2)
    if int(s,2)>130:
        res.append(int(s,2))

print(min(res))

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. К этой записи дописываются справа ещё два разряда по следующему правилу:
#a) складываются все цифры двоичной записи, и остаток от деления суммы на 2 дописывается в конец числа (справа). Например, запись 11100 преобразуется в запись 111001;
#б) над этой записью производятся те же действия - справа дописывается остаток от деления суммы цифр на 2.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Сколько различных чисел, принадлежащих отрезку [210; 260], могут появиться на экране в результате работы автомата?
res = []
for n in range(1000):
    s = bin(n)[2:]
    s += str(s.count('1')%2)
    s += str(s.count('1')%2)
    if 210<=int(s,2)<=260:
        res.append(int(s,2))
print(len(res))


#Автомат обрабатывает натуральное число N по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) Запись «переворачивается», то есть читается справа налево. Если при этом появляются ведущие нули, они отбрасываются.
#3) Полученное число переводится в десятичную систему счисления и выводится на экран.
#Какое наибольшее число, не превышающее 500, после обработки автоматом даёт результат 13?

for n in range(500, 0, -1):
    s = bin(n)[2:]
    if int(s[::-1], 2) == 13:
        print(n)
        break

#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#4) Из нового числа вычитается исходное, полученная разность выводится на экран.
#Для какого значения N результат работы алгоритма равен 45?
for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    for i in s:
        if i == '1' :
            s1+='0'
        else:
            s1+='1'
    if int(s1,2)-n==45:
        print(n)


#Автомат обрабатывает натуральное число N < 256 по следующему алгоритму:
#1) Строится восьмибитная двоичная запись числа N.
#2) Инвертируются все разряды исходного числа, кроме последней единицы и стоящих за ней нулей (0 заменяется на 1, 1 на 0).
#3) Полученное число переводится в десятичную систему счисления.
#ля какого значения N результат работы алгоритма равен 193?

for n in range(256):
    s = bin(n)[2:].zfill(8)
    s1 = ''
    i1 = s.rindex('1')
    for i in range(i1):
        if s[i] == '1': s1 += '0'
        else: s1+='1'
    s1+=s[i1:]
    if int(s,2)==193:
        print(n)


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2) Затем справа дописываются два разряда: символы 01, если число N чётное, и 10, если нечётное.
#Полученная таким образом запись (в ней на два разряда больше, чем в записи исходного числа N) является двоичной записью искомого числа R. 
#Укажите минимальное число N, после обработки которого автомат получает число, большее 138. 
#В ответе это число запишите в десятичной системе.

for n in range(1000):
    s = bin(n)[2:]
    if n % 2 == 0: s+='01'
    else: s+='10'
    if int(s, 2)>138:
        print(n)
        break

#Автомат обрабатывает натуральное число N > 1 по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) В конец записи (справа) дописывается вторая справа цифра двоичной записи.
#3) В конец записи (справа) дописывается вторая слева цифра двоичной записи.
#4) Результат переводится в десятичную систему. Пример. Дано число N = 11. Алгоритм работает следующим образом.
#Для скольких значений N в результате работы алгоритма получится число, принадлежащее отрезку [150; 200]?
k = 0
for n in range(2, 1000):
    s = bin(n)[2:]
    s += s[-2] + s[1]
    if 150 <= int(s, 2) <= 200:
        k += 1
print(k)


#Автомат обрабатывает десятичное натуральное число N по следующему алгоритму:
#1) Строится двоичная запись числа N.
#2) К полученному числу справа дописывается 0, если в числе сдиниц больше, чем нулей; иначе дописывается 1.
#3) Из середины двоичного числа убирается 2 разряда, если количество разрядов получилось четным, и 3 разряда, если нечетное.
#4) Результат переводится в десятичную систему. Пример. Дано число N = 11. Алгоритм работает следующим образом.
#1) Двоичная запись числа N: 11 = 10112
#2) Единиц больше, чем нулей, новая запись 101102.
#3)
#Длина начётная, удаляем три средних разряда, новая запись 102.
#4) Десятичное значение полученного числа 2.
#Для скольких различных значений N в результате работы автомата получается число 58?
k = 0
for n in range(4,100000):
    s = bin(n)[2:]
    if s.count('1') > s.count('0'):
         s+='0'
    else: s += '1'
    m = len(s)//2
    if len(s)%2 ==0:
        s = s[:m-1] + s[m+1:]
    else: s = s[:m-1] + s[m+2:]
    if int(s, 2)==58:
        k+=1
print(k)

#Алгоритм получает на вход натуральное число N > 1 и строит по нему новое число R следующим образом:
#1) Строится двоичная запись числа N.
#2) Подсчитывается количество нулей и единиц в полученной записи. Если их количество одинаково, в конец записи добавляется её последняя цифра. В противном случае в конец записи добавляется цифра, которая встречается реже.
#3) Шаг 2 повторяется сщё два раза.
#4) Результат переводится в десятичную систему счисления.
#При каком наименьшем исходном числе N > 80 в результате работы алгоритма получится число, кратное 4?

for n in range(81, 1000):
    s = bin(n)[2:]
    if s.count("1")== s.count("0"):
        s += s[-1]
    else:
        if s.count("1") > s.count("0"):
            s+='0'
        else:
            s+='1'
    if s.count("1")== s.count("0"):
        s += s[-1]
    else:
        if s.count("1") > s.count("0"):
            s+='0'
        else:
            s+='1'
    if int(s, 2)%4==0:
        print(n)
        break
        
#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Строится двоичная запись числа N.
#2)
#К этой записи дописываются ещё несколько разрядов по следующему
#правилу:
#a) если N чётное, то к нему справа приписывается в двоичном виде сумма цифр его двоичной записи;
#б) если N нечётное, то к нему справа приписываются два нуля, а слева единица. Например, двоичная запись числа 1101 будет преобразована в 1110100.
#Полученная таким образом запись (в ней как минимум на один разряд больше, чем в записи исходного числа N) является двоичной записью искомого числа R.
#Укажите наименьшее число N, для которого результат работы данного алгоритма больше 215. В ответе это число запишите в десятичной системе счисления. 

for n in range(1, 10000):
    s = bin(n)[2:]
    if n%2==0:
        s += bin(s.count('1'))[2:]
    else:
        s = '1' + s + '00'
    if int(s, 2)>215:
        print(n)
        break


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) если сумма цифр двоичной записи чётная, то к этой записи справа дописывается 0, а два левых разряда заменяются на 10;
#б) если сумма цифр двоичной записи нечётная, то к этой записи справа дописывается 1, а два левых разряда заменяются на 11.
#Полученная таким образом запись является двоичной записью искомого числа R.
#Например, для исходного числа 6 = 1102 результатом является 10002 = 8, а для исходного числа 4 = 1002 результатом является 11012 = 13. 
#Укажите минимальное число N, после обработки которого с помощью этого алгоритма получается число R, большее 50. 
# В ответе запишите это число в десятичной системе счисления.

for n in range(1, 10000):
    s = bin(n)[2:]
    if s.count('1')%2==0:
        s = '10' + s[:-2] + '0'
    else:
        s = '11' + s[:-2] + '1'


#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится двоичная запись числа N.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) если число N делится на 3, то к этой записи дописываются три последние двоичные цифры;
#б) если число N на 3 не делится, то остаток от деления умножается на
#3, переводится в двоичную запись и дописывается в конец числа. Полученная таким образом запись является двоичной записью искомого числа R.
#3. Результат переводится в десятичную систему и выводится на экран. Например, для исходного числа 12 = 11002 результатом является число 11001002 = 100, а для исходного числа 4 = 1002 это число 100112 = 19.
#Укажите минимальное число R, большее 151, которое может быть получено с помощью описанного алгоритма. В ответе запишите это число в десятичной системе счисления.

res = []
for n in range(1, 1000):
    s = bin(n)[2:]
    if n%3==0:
        s += s[-3:]
    else:
        s += bin(n%3*3)[2:]
    if int(s, 2)>151:
        res.append(int(s, 2))
print(min(res))

#*На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом:
#1. Строится двоичная запись числа N.
#2. Если число N делится на 3, в конец двоичной записи дописывается двоичный код числа 3, иначе дописывается единица.
#3. Если число, полученное после шага 2, делится на 5, в конец двоичной записи дописывается двоичный код числа 5, иначе дописывается единица.
#4. Полученная таким образом запись является двоичной записью искомого числа
#R.
#Например, для исходного числа 710 = 1112 (не делится на 3) после шага 2 получается число 11112 = 1510 (делится на 5), а после шага 3 - число 11111012
#=
#12510. Определите наибольшее возможное значение N, для которого в результате работы алгоритма получается R < 106.
for n in range(10000,0,-1):
    s = bin(n)[2:]
    s+= bin(3)[2:] if n%3==0 else '1'
    i = int(s, 2)
    s+= bin(5)[2:] if i%5==0 else '1'
    if int(s, 2)<10**6:
        print(n)
        break

#(PRO100-EГЭ) На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1. Строится троичная запись числа N.
#2. К этой записи дописываются справа ещё несколько разрядов по следующему
#правилу:
#a)
#если N чётное, то к нему справа приписываются два нуля, а слева
#единица;
#б) если N нечётное, то к нему справа приписывается в троичном виде сумма цифр его троичной записи.
#Полученная таким образом запись (в ней как минимум на один разряд больше, чем в записи исходного числа N) является троичной записью искомого числа R.
#Например, исходное число 410 = 113 преобразуется в число 111003 = 11710, а исходное число 710 = 213 преобразуется в число 21103 = 6610-
#Укажите такое наименьшее число N, для которого число R больше числа 168. 
# В ответе запишите это число в десятичной системе счисления.

def theree(x):
    res = ''
    while x:
        res+=str(x%3)
        x//=3
    return res[::-1]
for n in range(1,10000):
    s = theree(n)
    if n%2==0:
        s = '1'+s+'00'
    else:
        s += theree(sum(map(int,s)))
    if int(s,3)>168:
        print(n)
        break

#*(П. инкель) На вход алгоритма подаётся пятизначное натуральное число N. Алгоритм строит по нему новое число R следующим образом:
#1. Число N переводится в двадцатеричную систему счисления.
#2. Далее эта запись обрабатывается по следующему правилу:
#a) гласные буквы (А, Е, I) заменяются на 1;
#б) в конец полученной записи дописывается остаток от деления числа N на 20 в двадцатеричной системе счисления;
#b) первая цифра переставляется в конец записи.
#3. Действия а)-в) в п. 2. повторяются еще раз.
#Полученная таким образом запись является записью искомого числа R в двадцатеричной системе счисления. 
#Укажите максимальное число R, кратное 2030, которое может быть получено в результате работы алгоритма. 
#Запишите его в ответе в десятичной системе счисления.
res = []
def f(x):
    stroka = '0123456789ABCDEFGHI'
    if x < 20: return stroka[x]
    return f(x//20)+stroka[x%20]
for n in range(10**4, 10**5):
    s = f(n)
    s = s.replace('A','1').replace('E','1').replace('I','1')
    s+= f(n%20)
    s = s[1:]+s[0]
    s = s.replace('A','1').replace('E','1').replace('I','1')
    s+= f(n%20)
    s = s[1:]+s[0]
    if int(s,20)%2030==0:
        res.append(int(s,20))
print(max(res))

#Автомат получает на вход пятизначное число. По этому числу строится новое число по следующим правилам.
#1. Складываются отдельно первая, третья и пятая цифры, а также вторая и четвёртая цифры.
#2. Полученные два числа записываются друг за другом в порядке неубывания без разделителей.
#Пример. Исходное число: 63 179. Суммы: 6 + 1 + 9 = 16; 3 + 7 = 10. Результат: 1016. Укажите наименьшее число, при обработке которого автомат выдаёт результат 723.

#На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
#1) Вычисляется сумма S1 всех нечётных цифр десятичной записи числа N. Если нечётных цифр нет, сумма S1 считается равной 0.
#2) Вычисляется сумма S2 всех цифр десятичной записи числа N, стоящих в чётных разрядах. Разряды нумеруются справа налево, начиная с 0.
#3) Вычисляется результат R как модуль разности S1 и S2.
#Например, N = 1234. Сумма нечётных цифр S1 = 1 + 3 - 4. Сумма цифр в чётных разрядах S2 = 2 + 4 = 6. Результат работы алгоритма R = 6 4 = 2.
#Укажите наименьшее число, в результате обработки которого по данному алгоритму получится число 29.
for n in range(1, 10000):
    s = str(n)[::-1]
    s1 = sum(int(i)for i in s if i in '13579')
    s2 = sum(int([i])for i in range(0,len(s),2))
    if abs(s1-s2)==29:
        print(n)
        break

#Автомат получает на вход трёхзначное число. По этому числу строится новое число по следующим правилам.
#1. Из цифр, образующих десятичную запись N, строятся наибольшее и наименьшее возможные двузначные числа (числа не могут начинаться с нуля).
#2. На экран выводится разность полученных двузначных чисел. Пример. Дано число N = 351. Наибольшее двузначное число из заданных цифр
#53, наименьшее - 13. На экран выводится разность 53 - 13 = 40.
#Чему равно количество чисел N на отрезке [300; 400], в результате обработки которых на экране автомата появится число 20?
k= 0
for n in range(300,401):
    s = sorted(str(n))
    if s[0]=='0':
        if s[1] ==  '0':
            maxim = minim = int(s[2]+'0')
        else:
            minim = int(s[1]+ '0')
            maxim = int(s[2]+s[1])
    else:
        minim = int(s[0]+s[1])
        maxim = int(s[2]+s[1])
    if maxim-minim == 20:
        k+=1
print(k)

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

#6 задание Егэ по информатике


#Повтори 16 [Налево 36 Вперёд 4 Налево 36]
# Определите, сколько точек с целочисленными координатами будут находиться внутри области, ограниченной линией, заданной данным алгоритмом. 
# Точки на линии следует учитывать.

from turtle import *
tracer(0)

left(90)
for i in range(16):
    left(36)
    forward(4*40)
    left(36)

penup()
for x in range(-10, 10):
    for y in range(-10, 10):
        setpos(x*40, y*40)
        dot(4, 'red')

#Задача (ЕГЭ по информатике 2023, объединение фигур)
#Повтори 2 [Вперёд 10 Направо 90 Вперёд 18 Направо 90]
#Поднять хвост
#Вперёд 5 Направо 90 Вперёд 7 Налево 90
#Опустить хвост
#Повтори 2 [Вперёд 10 Направо 90 Вперёд 7 Направо 90]
#Определите, сколько точек с целочисленными координатами будут находиться внутри объединения фигур, ограниченных заданными алгоритмом линиями, включая точки на линиях.

import turtle

# Инициализация Черепахи
t = turtle.Turtle()
t.speed(999)  # Установка максимальной скорости черепахи

# Функция для выполнения команды "Вперёд n"
def forward(n):
    t.forward(n)

# Функция для выполнения команды "Назад n"
def backward(n):
    t.backward(n)

# Функция для выполнения команды "Направо m"
def right(m):
    t.right(m)

# Функция для выполнения команды "Налево m"
def left(m):
    t.left(m)

# Функция для выполнения команды "Поднять хвост"
def pen_up():
    t.penup()

# Функция для выполнения команды "Опустить хвост"
def pen_down():
    t.pendown()

# Функция для выполнения команды "Повтори k [Команда1 Команда2 … КомандаS]"
def repeat(k, commands):
    for _ in range(k):
        for command in commands:
            command()

# Выполнение алгоритма
repeat(2, [forward(10), right(90), forward(18), right(90)])
pen_up()
forward(5)
right(90)
forward(7)
left(90)
pen_down()
repeat(2, [forward(10), right(90), forward(7), right(90)])

# Завершение работы черепахи
turtle.done()

#Задача (Досрок 2024, Пересечение фигур)
# Черепахе был дан для исполнения следующий алгоритм:
# Повтори 2 [Вперёд 13 Направо 90 Вперёд 18 Направо 90]
# Поднять хвост
# Вперёд 5 Направо 90 Вперёд 9 Налево 90
# Опустить хвост
# Повтори 2 [Вперёд 11 Направо 90 Вперёд 7 Направо 90]
# Определите, сколько точек с целочисленными координатами будут находиться внутри пересечения фигур, ограниченных заданными алгоритмом линиями, включая точки на линиях.

import turtle

# Инициализация Черепахи
t = turtle.Turtle()
t.speed(0)  # Установка максимальной скорости черепахи

# Функция для выполнения команды "Вперёд n"
def forward(n):
    t.forward(n)

# Функция для выполнения команды "Назад n"
def backward(n):
    t.backward(n)

# Функция для выполнения команды "Направо m"
def right(m):
    t.right(m)

# Функция для выполнения команды "Налево m"
def left(m):
    t.left(m)

# Функция для выполнения команды "Поднять хвост"
def pen_up():
    t.penup()

# Функция для выполнения команды "Опустить хвост"
def pen_down():
    t.pendown()

# Функция для выполнения команды "Повтори k [Команда1 Команда2 … КомандаS]"
def repeat(k, commands):
    for _ in range(k):
        for command in commands:
            command()

# Выполнение алгоритма
repeat(2, [forward(13), right(90), forward(18), right(90)])
pen_up()
forward(5)
right(90)
forward(9)
left(90)
pen_down()
repeat(2, [forward(11), right(90), forward(7), right(90)])

# Завершение работы черепахи
turtle.done()


#Задача (ЕГЭ по информатике 2024, Периметр фигуры)

#Черепахе был дан для исполнения следующий алгоритм:
#Повтори 9 [Вперёд 22 Направо 90 Вперед 6 Направо 90]
#Поднять хвост
#Вперед 1 Направо 90 Вперёд 5 Налево 90
#Опустить хвост
#Повтори 9 [Вперёд 53 Направо 90 Вперёд 75 Направо 90]
#Определите периметр области пересечения фигур, ограниченных заданными алгоритмом линиями.

import turtle

# Инициализация Черепахи
t = turtle.Turtle()
t.speed(0)  # Установка максимальной скорости черепахи

# Функция для выполнения команды "Вперёд n"
def forward(n):
    t.forward(n)

# Функция для выполнения команды "Назад n"
def backward(n):
    t.backward(n)

# Функция для выполнения команды "Направо m"
def right(m):
    t.right(m)

# Функция для выполнения команды "Налево m"
def left(m):
    t.left(m)

# Функция для выполнения команды "Поднять хвост"
def pen_up():
    t.penup()

# Функция для выполнения команды "Опустить хвост"
def pen_down():
    t.pendown()

# Функция для выполнения команды "Повтори k [Команда1 Команда2 … КомандаS]"
def repeat(k, commands):
    for _ in range(k):
        for command in commands:
            command()

# Выполнение алгоритма
repeat(9, [forward(22), right(90), forward(6), right(90)])
pen_up()
forward(1)
right(90)
forward(5)
left(90)
pen_down()
repeat(9, [forward(53), right(90), forward(75), right(90)])

# Завершение работы черепахи
turtle.done()

#Задача (Составляем уравнения)

#Запись Повтори k [Команда 1 Команда 2 ... Команда S] означает, что последовательность из S команд повторится k раз.
#Черепахе был дан для исполнения следующий алгоритм:
#Вперёд 100 Направо 90 Вперёд 100 Направо 30 Опусти Повтори 10 [Вперёд 25 Направо 90]
#Определите, сколько точек с целочисленными координатами будут находиться внутри области, ограниченной линией, заданной данным алгоритмом. Точки на линии учитывать не следует.

import turtle

# Инициализация Черепахи
t = turtle.Turtle()
t.speed(0)  # Установка максимальной скорости черепахи

# Функция для выполнения команды "Вперёд n"
def forward(n):
    t.forward(n)

# Функция для выполнения команды "Направо m"
def right(m):
    t.right(m)

# Функция для выполнения команды "Опусти"
def pen_down():
    t.pendown()

# Функция для выполнения команды "Повтори k [Команда1 Команда2 … КомандаS]"
def repeat(k, commands):
    for _ in range(k):
        for command in commands:
            command()

# Выполнение алгоритма
forward(100)
right(90)
forward(100)
right(30)
pen_down()
repeat(10, [forward(25), right(90)])

# Завершение работы черепахи
turtle.done()



#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

#7 задание Егэ по информатике

#Задача (классика, количество цветов изображения)
#Какое максимальное количество цветов может быть в палитре неупакованного растрового изображения, имеющего размер 1024 * 256 пикселей и занимающего на диске не более 165 кб.

#1. Найдём сколько будет весить один пиксель! У нас всего 1024 * 256 пикселей. Берём максимально возможный объём картинки (165 Кб) и разделим его на количество пикселей.
#Нам нужно найти: сколько именно целых бит занимает один пиксель. 
#Округляем количество бит в меньшую сторону, потому что мы не можем "перевалить" за максимальную отметку 165 Кб для всего изображения.
# 2 в 5 = 32

# N = 2 в степени i
# N = 2^i

#########

#Задача (Резервирование памяти)
# Какой минимальный объём памяти (в Кбайт) нужно зарезервировать, чтобы можно было сохранить любое растровое изображение размером 64 * 256 пикселей при условии,
#  что в изображении могут использоваться 4 различных цвета? 
# В ответе запишите только целое число, единицу измерения писать не нужно.
#Задача обратная предыдущей. Первый вопрос на который нужно ответить: сколько весит 1 пиксель? Снова используется формула N = 2^i.

#Видно, что 1 пиксель имеет объём i = 2 бита. Количество пикселей в изображении равно 64 * 256. 
#Важно опять умножать эти два числа не сразу. Тогда объём картинки будет равен: количество пикселей (64 * 256) умножить на объём одного пикселя (2 бита).
#V = 64 * 256 * 2 бита =(64*256*2 байт)/8 =(64*256*2)/ (8*1024)


#######
#Задача (работа со звуком)
#Производится звукозапись музыкального фрагмента в формате квадро (четырёхканальная запись) с частотой дискретизации 16 кГц и 24-битным разрешением.
#  Результаты записываются в файл, сжатие данных не производится; размер полученного файла 60 Мбайт. 
# Затем производится повторная запись этого же фрагмента в формате стерео (двухканальная запись) с частотой дискретизации 64 кГц и 16-битным разрешением. 
# Сжатие данных не производилось. #Укажите размер файла в Мбайт, полученного при повторной записи. 
# В ответе запишите только целое число, единицу измерения писать не нужно.

#Общая формула для решения 7-ого задания на тему звуковых файлов из ЕГЭ по информатике.



###############################################
#Формула дискретизации
#V = M * i * t
#M - частота дискретизации (в Гц)
#i- Разрешение (в битах)
#t - время звучания (в сек)
#V - объем файла В битах
#(режим стерео - умножить на 2, квадро - на 4)
###############################################



#Её легко запомнить. Объём записанного файла равен произведению всех остальных параметров. Важно соблюдать единицы измерения.
#Распишем формулу дискретизации для первой звукозаписи и для второй.
#В первом случае у нас режим квадро, значит, нужно к произведению добавить ещё 4. 
# Во втором случае режим стерео, значит, должны поставить коэффициент 2. Т.к. производилась запись этого же фрагмента, то время в обоях случаях одинаковое.


#1 запись звукового файла:
#60 Мб = 4 * 16 кГц * 24 бит * t

#t = 60 Мб /(4*16 кГц 24 бит)
#2 запись звукового файла:
#V = 2 * 64 кГц * 16 бит
# V = 2 * 64 кГц * 16 бит * 60 Мб /(4*16 кГц 24 бит) = 80 Мб

#######################

#Задача (ЕГЭ по информатике 2020, Досрочная волна)
#Музыкальный фрагмент был записан в формате квадро (четырёхканальная запись), оцифрован и сохранён в виде файла без использования сжатия данных. 
# Размер полученного файла без учёта размера заголовка файла – 12 Мбайт. 
# Затем тот же музыкальный фрагмент был записан повторно в формате моно и оцифрован с разрешением в 2 раза выше и частотой дискретизации в 1,5 раза меньше, чем в первый раз.
#  Сжатие данных не производилось. Укажите размер в Мбайт файла, полученного при повторной записи.
#  В ответе запишите только целое число, единицу измерения писать не нужно. 
# Искомый объём не учитывает размера заголовка файла.

#Вначале выписываем формулу для первого файла и для второго файла. Подставляем всё, что нам известно.
#Для второго звукового файла коэффициенты все переносим в одну сторону.
#Выражаем из первого уравнения произведение M * i * t и подставляем его во второе уравнение.

#1 запись звукового файла:
#12 = 4 * M * i * t
#2 запись звукового файла:

#V2 = M/1,5 *2 * i * t
#V2 = 2 /1,5 * 12/4 = 4

##################################

#Задача (Cнимки группируются в пакеты)
#Прибор автоматической фиксации нарушений правил дорожного движения делает цветные фотографии размером 1024×768 пикселей, используя палитру из 4096 цветов. 
# Для передачи снимки группируются в пакеты по 256 штук. 
# Определите размер одного пакета фотографий в Мбайт.

#Найдём сколько весит один пиксель фотографии.

#N = 2 ^ i
#4096 = 2 ^ 12.

#Один пиксель весит i = 12 бит. Найдём сколько весит одна фотография:

#1024 *768 *12 = 9437184

#Найдём сколько весит весь пакет.
#9437184 бит * 256 = 2415919104 бит
#Найдём сколько весит весь пакет в Мб.

#V = 2415919104 / (1024*1024*8) = 288 Мб

#################################


#Задача (Пакет и скорость)
#Прибор автоматической фиксации нарушений правил дорожного движения делает цветные фотографии размером 1024×960 пикселей, используя палитру из 8192 цветов. 
# Снимки сохраняются в памяти камеры, группируются в пакеты по 160 шт., затем передаются в центр обработки информации со скоростью передачи данных 14 680 064 бит/с. 
# Сколько секунд требуется для передачи одного пакета фотографий?
#В ответе запишите целую часть полученного числа.

#Найдём сколько весит один пиксель фотографии.
#N = 2 ^ i
#8192 = 2 ^ 13.

#Один пиксель весит i = 13 бит. Найдём сколько весит одна фотография:
#1024 *960 *13 = 12779520 бит

#Найдём сколько весит весь пакет.
#12779520 бит * 160 = 2044723200 бит

#Один пакет будет передаваться:

# t = 2044723200 / 14680064 = 139.3
#В ответе просили записать целую часть результата.

####################
#Задача (Звуковой файл, скорость)
# Голосовое сообщение продолжительностью 90 с было записано в формате стерео и оцифровано с глубиной кодирования 16 бит и частотой дискретизации 48 000 измерений в секунду.
#  Сжатие данных не использовалось. 
# Файл с оцифрованным голосовым сообщением был передан по каналу связи, пропускная способность которого 3200 бит/с. 
# Сколько секунд длилась передача файла? 
# В ответе запишите целое число, единицу измерения указывать не нужно.

#Найдём сколько весит звуковой файл.
# V = 4 * M * i * t
#967 *1024*1024*8 = 4 + 960000 * 8 * t

# t = (967 *1024 *1024*8) / (4 * 960000 * 8) = 2640,6
# t = 2640 /60 = 44 мин.

###########################
#Задача (ЕГЭ по информатике 7.06.24)
#Имеется музыкальный альбом без сжатия в формате стерео с частотой дискретизации 48000 Гц и разрешением 34 бита. 
# В альбоме 13 треков общей длительностью 42 мин 20 сек. Каждый трек содержит заголовок 110 Кбайт. 
# Сколько секунд будет скачиваться альбом по каналу связи со скоростью данных 314572800 бит/c ? 
# В ответе запишите целую часть полученного числа.

#Найдём объём всего альбома без учёта заголовков. Переведём время в секунды t = 42 мин 20 сек = 2540 сек.

#Vалб = 2 * M * i * taлб
#Vалб = 2 * 48000 Гц * 34 бит * 2540 с
#Vалб = 8290560000 бит

#Добавим к этому объёму заголовки. Один заголовок 110 Кбайт = 110 * 1024 * 8 бит = 901120 бит. 
# Для всего альбома 13 * 901120 бит = 11714560 бит. 
# Получается:
#Vалб - общ = 8290560000 бит + 11714560 бит = 8302274560 бит
# t = 8302274560 / 314572800 = 26.39
# Ответ 26

##################
#Задача (ЕГЭ по информатике 8.06.24)
#Прибор автоматической фиксации нарушений правил дорожного движения делает цветные фотографии размером 1024х960 пикселей, используя палитру из 2048 цветов. 
# Снимки сохраняются в памяти камеры, группируются в пакеты по несколько штук, а затем передаются в центр обработки информации со скоростью передачи данных 96 468 992 бит/с. 
# Каково максимально возможное число снимков в одном пакете, если на передачу одного пакета отводится не более 280 секунд?
#В ответе запишите целое число.

#Решение:
#Найдём, сколько весит один пиксель.
#N = 2' = 211 = 2048
#Получается 11 бит весит один пиксель. Найдём, сколько весит одна фотография.
#V = 1024 * 960 * 11 бит = 10813440 бит
#Пусть в пакете будет х фотографий. Тогда пакет будет весить х*V. 
# Время, за которое будет передаваться пакет, будет равно:
# t = x* 10813440 бит / 96 468 992 бит/с
# Нам сказали, что время не должно превышать 280 с.
# t = (x* 10813440 бит) / (96 468 992 бит/с) ≤ 280 с
# x = (280 * 96 468 992 бит/с) / (10813440 бит) = 2497,9
# Ответ 2497

######################

#Задача (ЕГЭ по информатике 19.06.24)
#Прибор автоматической фиксации нарушений правил дорожного движения делает цветные фотографии размером 1280×1024 пикселей. Снимки сохраняются в памяти камеры, группируются в пакеты по 39 штук, затем передаются в центр обработки информации со скоростью передачи данных 1 966 080 бит/с. Каково максимально возможное количество цветов в палитре изображения, если на передачу одного пакета отводится не более 280 секунд?
#В ответе запишите целое число.

#Решение:
#Обозначим за х вес одного пикселя.
#Тогда размер картинки будет:
#V = 1280 * 1024 * x
#Тогда пакет будет весить:
#Vп = 39 * 1280 * 1024 * x
#Выразим время передачи одного пакета.
#t = (Vп/v) =  (39 * x* 1280 * 1024 бит)/ (1966080 бит / с) <= 280 с
# x <= (280 * 1966080 бит / с) / (39 * 1280 * 1024 бит) = 10,8
#Максимальное целое значение х получается равно 10.
#Тогда максимальное количество цветов равно:
#N = 210 = 1024
#Ответ: 1024


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________


#8 задание Егэ по информатике
#Шифр кодового замка представляет собой последовательность из пяти символов, каждый из которых является цифрой от 1 до 4.
#  Сколько различных вариантов шифра можно задать, если известно, что цифра 1 встречается ровно два раза,
#  а каждая из других допустимых цифр может встречаться в шифре любое количество раз или не встречаться совсем?
from itertools import product 
alphabet = '1234'
ap=[]
for i in product(alphabet, repeat=5):    
    if i.count('1') == 2:
        ap.append(i)
print(len(ap))

#Составляют 5-⁠буквенные слова из букв слова ПЯТНИЦА. 
#Найти количество слов, которые не начинаются с Н и в которых есть только одна буква Я.
#Буквы в слове могут повторяться.
from itertools import product
count = 0
for p in product("ПЯТНИЦА", repeat=5):
    if p.count("Я") == 1 and p[0]!="Н":
        count+=1
print(count)

#Сколько существует чисел, восьмеричная запись которых содержит 5 цифр, причем в записи нет цифры 1. 
# Также все цифры записи различны и никакие две чётные и две нечётные цифры не стоят рядом.

from itertools import *
word = '0234567'
count = 0
for i in permutations(word,5):
    x = ''.join(i)
    if x[0] != '0':
        x = x.replace('7','1').replace('5','1').replace('3','1').replace('6','0').replace('4','0').replace('2','0')
        if ('00' not in x) and ('11' not in x):
            count += 1
print(count)


#Все 5-буквенные слова, в составе которых могут быть буквы А, Л, Г, О, Р, И, Т, М, записаны в алфавитном порядке и пронумерованы начиная с 1.

#Определите в этом списке количество слов с нечетными номерами,
#  которые не начинаются с буквы Г и при этом содержат в своей записи не менее двух букв И.

from itertools import product
count = 0
number = 0
for p in product(sorted("АЛГОРИТМ"), repeat=5):
    number += 1
    if number % 2 != 0 and p[0]!="Г" and p.count("И") >= 2:
        count+=1
print(count)

#Сколько существует десятичных чисел, которые делятся на 5, при условии что все цифры числа различные?
from itertools import permutations
word = '0123456789'
c = 0
for j in range(1,11):
    for i in permutations(word,j):
        x = ''.join(i)
        if x[0] != '0' and (x[-1] == '5' or x[-1] == '0'):
            c += 1
print(c + 1) #+1 случай когда число равно 0

#Джон составляет список всех возможных кодов, составленных из заглавных латинских букв.
#  Сначала он выписывает в алфавитном порядке все коды, состоящие из одного символа (A, B, …, Z),
#  затем  — тоже в алфавитном порядке  — коды из двух символов (AA, AB, …, AZ, BA, BB, … ZZ),
#  далее идут трёхсимвольные коды (AAA, AAB, …, ZZZ) и так далее.

#Под каким номером окажется в этом списке код FDECBA?

from itertools import product
 
count = 1
alf = sorted('QWERTYUIOPASDFGHJKLZXCVBNM')
for n in range(1,7):
    for i in product(alf,repeat = n):
        if "".join(i)=="FDECBA":
            print(count)
            break
        count += 1




#Миша составляет 6-буквенные коды из букв Б, А, Н, К, И, Р. Каждая допустимая гласная буква может входить в код не более одного раза. Сколько кодов может составить Миша?

from itertools import product

k = 0
for w in product('БАНКИР',repeat=6):
    if w.count('А') <= 1 and w.count('И') <= 1:
        k += 1
print(k)


#Из букв слова Р А З М А Х составляются 6-буквенные последовательности. 
# Сколько можно составить различных последовательностей, если известно, что в каждой из них содержится не менее 3 согласных?

from itertools import product

k = 0
for w in product('РАЗМХ',repeat=6):
    if w.count('Р') + w.count('З') + w.count('М') + w.count('Х') >= 3:
        k += 1
print(k)

#or 
from itertools import product

k = set()
for w in product('РАЗМАХ',repeat=6):
    if w.count('Р') + w.count('З') + w.count('М') + w.count('Х') >= 3:
        k.add(w)
print(len(k))

#Василий составляет 4-буквенные коды из букв В, А, Я, Ю, Щ, И, Й. 
# Каждую букву можно использовать любое количество раз, при этом код не может начинаться с буквы Й и должен содержать хотя бы одну гласную.
# Сколько различных кодов может составить Василий?

from itertools import product

k = 0
for w in product('ВАЯЮЩИЙ',repeat=4):
    if w[0]!='Й' and w.count('А')+w.count('Я')+w.count('Ю')+w.count('И')>0: #код не может начинаться с буквы Й и должен содержать хотя бы одну гласную.
        k += 1
print(k)

#or
from itertools import product

k = 0
for w in product('ВАЯЮЩИЙ',repeat=4):
    if w[0]!='Й' and any(ch in 'АЯЮИ' for ch in w): #любая гласная в коде
        k += 1
print(k)



#Сергей составляет 5-буквенные коды из букв Ж, А, Л, Е, Й. 
# Буква Й может использоваться в коде не более одного раза, при этом она не может стоять на первом месте, на последнем месте и рядом с буквой Е. 
# Все остальные буквы могут встречаться произвольное количество раз или не встречаться совсем. Сколько различных кодов может составить Сергей?

from itertools import product

k = 0
for w in product('ЖАЛЕЙ',repeat=5):
    word = ''.join(w)
    if word.count('Й')<=1 and word[0] != 'Й' and word[-1] != 'Й' and 'ЕЙ' not in word and 'ЙЕ' not in word:
        k += 1
print(k)


#Петя составляет шестибуквенные слова перестановкой букв слова АДЖИКА.
#  При этом он избегает слов с двумя подряд одинаковыми буквами. 
# Сколько всего различных слов может составить Петя?

from itertools import permutations

k = set()
for w in permutations('аджика'):
    word = ''.join(w)
    if 'аа' not in word:
        k.add(word)
print(len(k))

#Маша составляет 7-буквенные коды из букв В, Е, Н, Т, И, Л, Ь.
#  Каждую букву нужно использовать ровно 1 раз, при этом буква Ь не может стоять на последнем месте и между гласными. Сколько различных кодов может составить Маша?

from itertools import permutations

k = 0
for w in permutations('вентиль'):
    word = ''.join(w)
    if word[-1] != 'ь' and "еьи" not in word and "иье" not in word:
        k += 1
print(k)

#Вася составляет слова из букв слова АММИАКАТ.
#  Код должен состоять из 8 букв, и каждая буква в нём должна встречаться столько же раз, сколько в заданном слове. 
# Кроме того, в коде должны стоять рядом две гласные или две согласные буквы. Сколько различных слов может составить Вася?

from itertools import permutations

k = set()
for w in permutations('аммиакат'):
    s = ''
    for i in w:
        s += 'g' if i in 'аи' else 's'
    if 'ss' in s or 'gg' in s:
        k.add(w)
print(len(k))


#Маша составляет коды из букв, входящих в слово КОНДРАТ. 
# Каждая буква должна входить в код ровно один раз. Все возможные коды Маша записывает в алфавитном порядке и нумерует. Начало списка выглядит так:
#1. АДКНОРТ
#2. АДКНОТР
#3. АДКНРОТ
#Какой код будет записан под номером 2233?

from itertools import permutations
print([i for i in permutations('адкнорт')][2232])

#Все 5-буквенные слова, составленные из букв Д, К, М, О, записаны в алфавитном порядке и пронумерованы. Вот начало списка:
#1. ДДДДД
#2. ДДДДК
#3. ДДДДМ
#4. ДДДДО
#5. ДДДКД
#Какое количество слов находятся между словами ДОМОК и КОМОД (включая эти слова)?

from itertools import product

k = [''.join(i) for i in product('дкмо',repeat=5)]
print(k.index('комод')-k.index('домок')+1)

#Все четырёхбуквенные слова, составленные из букв А, Л, Г, О, Р, И, Т, М, записаны в алфавитном порядке и пронумерованы, начиная с 1. Начало списка выглядит так:
#1. AAAA
#2. АААГ
#3. АААИ
#4. АААЛ
#5. АAAM
#6. ААAO
#7. АAAP
#8. АAAT
#9. ААГа
#Под каким номером в списке идёт первое слово, которое начинается с букв ГО?

from itertools import product

for i, x in enumerate(product(sorted('аглоритм'),repeat=4), 1):
    word = ''.join(x)
    if word[:2] == 'го':
        print(i)
        break



#Все пятибуквенные слова, составленные из букв К, О, М, П, Ь, Т, Е, Р записаны в алфавитном порядке и пронумерованы. Начало списка выглядит так:
#1. EEEEE
#2. EEEEK
#3. EEEEM
#4. EEEEO
#5. ЕЕEEП
#6. EEEEP
#7. EEEET
#8. ЕEEEb
#Под каким номером в списке стоит последнее слово с нечётным номером, которое не начинается с буквы и содержит ровно две буквы К?

from itertools import product

for i, x in enumerate(product(sorted('компьютер'),repeat=5), 1):
    if i % 2 and x[0] != 'ь' and x. count('к') == 2:
        print(i)

#(Е. Усов) Леся составляет новые предложения перестановкой букв и символов из предложения ХОЧУ В ВУЗ.
#  При этом она не любит слова, начинающиеся с буквы У. Предложением это несколько слов, разделённых между собой пробелами. 
# Слова не обязательно должны быть осмысленными словами русского языка. Сколько различных новых предложений может составить Леся?

from itertools import permutations

k = set()
for w in permutations('хочу в вуз'):
    word = ''.join(w)
    if word[0] != ' ' and word[-1] != ' ' and '  ' not in word and word[0] != 'у' and ' у' not in word:  
        k.add(word)
print(len(k)-1)


#*Добрыня составляет коды из букв, входящих в слово ДОБРЫНЯ.
#  Код должен состоять из 6 букв, буквы в коде не должны повторяться, согласных в коде должно быть больше, чем гласных, две гласные буквы нельзя ставить рядом.
#  Сколько различных кодов может составить Добрыня?

from itertools import permutations

k = 0
for w in permutations('добрьян', r = 6):
    s = ''
    for c in w:
        s += 's' if c in 'дбрн' else 'g'
    if s.count('s') > s.count('g') and 'gg' not in s:
        k += 1
print(k)

#Сколько существует чисел, девятеричная запись которых состоит из шести цифр, не начинается с нечётных цифр, не оканчивается цифрами 2 и 3 и содержит не менее двух цифр 1?


from itertools import product

k = 0 
for x in product('012345678', repeat=6):
    if x[0] not in '013579' and x[-1] not in '23' and x. count('1') >= 2:
        k += 1
print(k)


#Определите количество пятизначных чисел, записанных в девятеричной системе счисления,
#  которые не начинаются с нечётных цифр, не оканчиваются цифрами 1 или 8, а также содержат в своей записи не более одной цифры 3.

from itertools import product

k = 0 
for x in product('012345678', repeat=5):
    if x[0] not in '01357' and x[-1] not in '18' and x. count('3') < 2:
        k += 1
print(k)

#Определите количество 12-ричных пятизначных чисел, в записи которых ровно одна цифра 7 и не более трёх цифр с числовым значением, превышающим 8.

from itertools import product
k = 0
for x in product('0123456789ab', repeat=5):
    if x[0] != '0' and x.count('7') == 1 and len([i for i in x if i in '9ab'])<4:
        k += 1
print(k)

#Сколько существует чисел, делящихся на 5, десятичная запись которых содержит 5 цифр, причём все цифры различны и никакие две чётные и две нечётные цифры не стоят рядом.

from itertools import permutations

k = 0
for x in permutations('0123456789', r=5):
    numd = ''.join(x)
    if numd[0] != '0' and numd [-1] in '05' \
        and all(int(numd[i])%2 != int(numd[i+1])%2 for i in range(len(numd)-1)):
        k += 1
print(k)

#_______________________________________________________________________________________________________________________________________________________________
# #_______________________________________________________________________________________________________________________________________________________________ 
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________


 #9 задание егэ по информатике
 #=СЧЁТЕСЛИ($A1:$E1; A1)
 #=СЧЁТЕСЛИ(F1:J1;1)
 #=(МИН(A1:E1) + МАКС(A1:E1))*2
 #=ЕСЛИ(И(K1=5;N1=1);1;0)


 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________

#11 задание егэ по информатике


 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________
 #_______________________________________________________________________________________________________________________________________________________________

 #12 задание егэ по информатике
 # Какая строка получится в результате применения приведённой ниже программы к строке, состоящей из 68 идущих подряд цифр 8? В ответе запишите полученную строку.

# НАЧАЛО

## ПОКА нашлось (222) ИЛИ нашлось (888)

# #   ЕСЛИ нашлось (222)

#        ТО заменить (222, 8)

#        ИНАЧЕ заменить (888, 2)

#   КОНЕЦ ЕСЛИ

# КОНЕЦ ПОКА

#КОНЕЦ

s='8'*68
while ('222' in s) or ('888' in s):
    if ('222' in s): 
        s=s.replace ('222','8',1)
    else:
        s=s.replace ('888','2',1)
print(s)

#Какая строка получится в результате применения приведённой ниже программы к строке, состоящей из цифры 1, за которой следуют 80 идущих подряд цифр 8? В ответе запишите полученную строку.

#НАЧАЛО

#  ПОКА нашлось (18) ИЛИ нашлось (288) ИЛИ нашлось (3888)

#    ЕСЛИ нашлось (18)

##      ТО заменить (18, 2)

#      ИНАЧЕ ЕСЛИ нашлось (288)

#        ТО заменить (288, 3)

#        ИНАЧЕ заменить (3888, 1)

#      КОНЕЦ ЕСЛИ

#    КОНЕЦ ЕСЛИ

#  КОНЕЦ ПОКА

#КОНЕЦ

s = '1' + '8' * 80
while '18' in s or '288' in s or '3888' in s:
    if '18' in s:
        s = s.replace('18','2',1)
    elif '288' in s:
        s = s.replace('288','3',1)
    else:
        s = s.replace('3888', '1',1)
print(s)




#Пример решения задачи через прогу
#Напишите сумму цифр строки, полученной в результате применения приведённой
#ниже программы к строке: 5 . . . 5

#НАЧАЛО
#ПОКА нашлось(5) ИЛИ нашлось(77) ИЛИ нашлось(222)
#ЕСЛИ нашлось(5)
#ТО заменить(5, 77)
#ИНАЧЕ ЕСЛИ нашлось(77)
#ТО заменить(77, 7)
#ИНАЧЕ ЕСЛИ нашлось(222)
#ТО заменить(222, 5)
#КОНЕЦ ЕСЛИ
#КОНЕЦ ПОКА
#КОНЕЦ
#Решение.

s = '5' * 10 + '7' * 30 + '2' * 50  # задаём строку

while s.find('5') != -1 or s.find('77') != -1 or s.find('222') != -1:
    # while - пока
    # s.find(s1) - находит индекс первого вхождения строки s1 в s
    # если не нашёл - возвращает -1
    if s.find('5') != -1:
        s = s.replace('5', '77', 1)
        # s.replace(s1, s2, 1) заменяет первое вхождение s1 в s на s2
    elif s.find('77') != -1:
        s = s.replace('77', '7', 1)
    elif s.find('222') != -1:
        s = s.replace('222', '5', 1)

print(sum(int(digit) for digit in s))




#Исполнитель Редактор получает на вход строку цифр и преобразовывает её. Редактор может выполнять две команды, в обеих командах v и w обозначают цепочки цифр.
#1. заменить (v, w)
# 2. нашлось (v)
# Первая команда заменяет в строке первое слева вхождение цепочки v на цепочку w, вторая проверяет, встречается ли цепочка v в строке исполнителя Редактор. 
# Если она встречается, то команда возвращает логическое значение «истина», в противном случае возвращает значение «ложь». 
# Какая строка получится в результате применения приведённой ниже программы к строке, состоящей из 101 единиц?
# ПОКА нашлось (1111)
# заменить (1111, 22)
# заменить (222, 1)
# КОНЕЦ ПОКА
# КОНЕЦ

s = 101 * '1'
while '1111' in s:
    s = s.replace('111', '22' , 1)
    s = s.replace('222', '1', 1)
print(s)

#Kакая строка получится в результате применения приведённой ниже программы к строке, состоящей из 79 семёрок?
# НАЧАЛО
# ПОКА нашлось (7777) ИЛИ нашлось (3333)
# ЕСЛИ нашлось (3333)
# ТО заменить (3333, 77)
# ИНАЧЕ
# заменить (7777, 33)
# конецесли
# конец

s = 79 * '7'
while '7777' in s or '3333' in s:
    if '3333' in s:
        s = s.replace('3333', '77', 1)
    else:
        s = s.replace('7777', '33', 1)
print(s)


#Ниже приведена программа для исполнителя Редактор.
# начало
# ПОКА нашлось (133) ИЛИ нашлось (881)
# ЕСЛИ нашлось (133)
# ТО заменить (133, 81)
# ИНАЧЕ заменить (881, 13)
# КОНЕЦЕСЛИ
# конец пока
# КОНЕЦ
# На вход этой программе подается строка, состоящая из 100 цифр; последняя цифра в строке цифра 1, а остальные цифры восьмёрки. 
# Какая строка получится в результате применения программы к этой строке? В ответе запишите полученную строку.

s = 99 * '8' + '1'
while '133' in s or '881' in s:
    if '133' in s:
        s = s.replace('133', '81', 1)
    else:
        s = s.replace('881', '13', 1)
print(s)

#Дана программа для исполнителя Редактор:
# начало
# ПОКА нашлось (63) ИЛИ нашлось (664) ИЛИ нашлось (6665)
# ЕСЛИ нашлось (63) ТО заменить (63, 4)
# ЕСЛИ нашлось (664) ТО заменить (664, 65)
# иначе
# ЕСЛИ нашлось (6665) ТО заменить (6665, 63) КОНЕЦ ЕСЛИ
# конецесли
# КОНЕЦЕСЛИ
# конец пока
# конец
# Какая строка получится в результате применения приведённой выше программы к строке, в которой первая и последняя цифры - 3, 
# а между ними стоит 115 цифр 6? В ответе запишите полученную строку.

s = '3' + 115 * '6' + '3'
while '63' in s or '664' in s or '6665' in s:
    if '63' in s:
        s = s.replace('63', '4', 1)
    elif '664' in s:
        s = s.replace('664', '65', 1)
    else:
        s = s.replace('6665', '63', 1)
print(s)


# Дана программа для Редактора:
# ПОКА нашлось (49) ИЛИ нашлось (97) ИЛИ нашлось (47)
# ЕСЛИ нашлось (47)
# ТО заменить (47, 74)
# конецесли
# ЕСЛИ нашлось (97)
# ТО заменить (97, 79)
# КОНЕЦЕСЛИ
# ЕСЛИ нашлось (49)
# ТО заменить (49, 94)
# конецесли
# КОНЕЦ
# На вход приведённой ниже программе поступает строка, содержащая 40 цифр 7, 40 цифр 9 и 50 цифр 4, расположенных в произвольном порядке.
#  Запишите без разделителей символы, которые имеют порядковые номера 25, 71 и 105 в получившейся строке. В ответе запишите полученную строку.
from random import shuffle #расположенных в произвольном порядке.
s = list(50 * '4' + 40 * '7' + 40 * '9') #расположенных в произвольном порядке.
shuffle(s)
s = ''.join(s)
while '49' in s or '97' in s or '47' in s:
    if '47' in s:
        s = s.replace('47', '74', 1)
    elif '97' in s:
        s = s.replace('97', '79', 1)
    elif '49' in s:
        s = s.replace('49', '94', 1)
print(s[24] + s[70] + s[104])

#На вход приведённой ниже программе поступает строка, начинающаяся с символа «>», а затем содержащая 10 цифр 1, 20 цифр 2 и 30 цифр 3, расположенных в произвольном порядке.
# Определите сумму числовых значений цифр строки, получившейся в результате выполнения программы.
# начало
# ПОКА нашлось (>1) ИЛИ нашлось (>2) ИЛИ нашлось (>3)
# ЕСЛИ нашлось (>1)
# ТО заменить (>1, 22>)
# ЕСЛИ нашлось (>2)
# ТО заменить (>2, 2>)
# ЕСЛИ нашлось (>3)
# ТО заменить (>3, 1>)
# конец пока

s =  '>' + 10 * '1' + 20 * '2' + 30 * '3'
while '>1' in s or '>2' in s or '>3' in s:
    if '>1' in s:
        s = s.replace('>1', '22>', 1)
    elif '>2' in s:
        s = s.replace('>2', '2>', 1)
    elif '>3' in s:
        s = s.replace('>3', '1>', 1)
s = s.replace('>', '0')
print(sum(map(int, s)))


# Дана программа для Редактора:
# начало
# ПОКА нашлось (11)
# ЕСЛИ нашлось (112)
# ТО заменить (112, 6)
# ИНАЧЕ заменить (11, 3)
# КОНЕЦ ПОКА
# КОНЕЦ
# Исходная строка содержит десять единиц и четыре двойки, других цифр нет, точный порядок расположения единиц и двоек неизвестен.
#  Какую наибольшую сумму цифр может иметь строка, которая получится после выполнения программы?
# В РУЧНУЮ

#Дана программа для исполнителя Редактор:
# начало
# ПОКА нашлось (25)
# заменить (25, 9)
# КОНЕЦ ПОКА
# КОНЕЦ
# Исходная строка содержит 12 пятерок и некоторое количество двоек, других цифр нет, точный порядок расположения пятерок и двоек неизвестен. 
# После выполнения программы получилась строка с суммой цифр 122. Какое наименьшее количество двоек могло быть в исходной строке?
# В РУЧНУЮ



# К исходной строке, содержащей более 50 единиц и не содержащей других символов, применили приведённую ниже программу.
# начало
# ПОКА нашлось (111)
# заменить (111, 2)
# заменить (222, 1)
# КОНЕЦ ПОКА
# В результате получилась строка 22. Какое наименьшее количество единиц могло быть в исходной строке?


for i in range(51, 100): #более 50 единиц
    s = '1' * i
    while '111' in s:
        s = s.replace('111', '2', 1) #заменить (111, 2)
        s = s.replace('222', '1', 1) #заменить (222, 1)
    if s == '22': #строка 22
        print(i) # количество единиц могло быть в исходной строке
        break  #наименьшее


#Дана программа для исполнителя Редактор:
# ПОКА нашлось (555) ИЛИ нашлось (888)
# заменить (555, 8)
# заменить (888, 55)
# КОНЕЦ ПОКА
# Известно, что начальная строка состоит более чем из 300 цифр 8 и не содержит других символов. 
# В ходе работы алгоритма получилась строка, содержащая больше цифр 5, чем цифр 8.
#  Укажите минимальную возможную длину входной строки.

for i in range(301, 1000):
    s = '8' * i
    while '555' in s or '888' in s:
        s = s.replace('555', '8', 1)
        s = s.replace('888', '55', 1)
    if s.count('5') > s.count('8'):
        print(i)
        break

# Дана программа для редактора:
# начало
# ПОКА нашлось (111)
# заменить (111, 22)
# заменить (222, 11)
# КОНЕЦ ПОКА
# КОНЕЦ
# Известно, что исходная строка содержала более 100 единиц и не содержала других цифр. 
# Укажите минимально возможную длину исходной строки, при которой в результате работы этой программы получится строка, содержащая минимально возможное количество единиц.

mn = 10 **10
for i in range(101, 1000):
    s = '1' * i
    while '111' in s:
        s = s.replace('111', '22', 1)
        s = s.replace('222', '11', 1)
    if s.count('1') < mn:
        mn = s.count('1')
        f = i
print(f)


#(Е. Джобс) Дана программа для исполнителя Редактор:
# начало
# ПОКА нашлось(1111) или нашлось(222) или нашлось(33)
# ЕСЛИ нашлось(1111)
# ТО заменить(1111, 333)
# иначе
# ЕСЛИ нашлось(222)
# ТО заменить(222, 11)
# ИНАЧЕ
# заменить(33, 2)
# конецесли
# конец если
# КОНЕЦ
# На вход программе подана непустая строка из подряд идущих символов 1.
# Сколько различных вариантов конечной строки может быть получено после
# выполнения приведенного алгоритма.

mn = set()
for i in range(1, 10000):
    s = '1' * i
    while '1111' in s or '222' in s or '33' in s:
        if '1111' in s:
            s = s.replace('1111', '333', 1)
        elif '222' in s:
            s = s.replace('222', '11', 1)
        else:
            s = s.replace('33', '2', 1)
    mn.add(s)
print(len(mn))

#Дана программа для исполнителя Редактор:
# начало
# ПОКА нашлось (555) ИЛИ нашлось (333)
# ЕСЛИ нашлось (555)
# ТО заменить (555, 3)
# ИНАЧЕ заменить (333, 5)
# конецесли
# конец пока
# конец
# Дана строка, состоящая из 400 цифр 5. Сколько троек было удалено за время обработки строки по этой программе?


s = 400* '5'
k = 0
while '555' in s or '333' in s:
    if '555' in s:
        s = s.replace('555', '3', 1)
    else:
        s = s.replace('333', '5', 1)
        k += 3
print(k)


# Дана программа для редактора:
# начало
# ПОКА нашлось (01) ИЛИ нашлось (02) ИЛИ нашлось (03)
# заменить (01, 30)
# заменить (02, 101)
# заменить (03, 202)
# КОНЕЦ ПОКА
# Известно, что исходная строка начиналась с нуля, а далее содержала только единицы, двойки и тройки. 
# После выполнения данной программы получилась строка, содержащая 15 единиц, 10 двоек и 60 троек. 
# Сколько единиц было в исходной строке?

for a in range(1, 50):
    for b in range(1, 50):
        for c in range(1, 50):
            s = '0' + a *'1' + b * '2' + c * '3'
            while '01' in s or '02' in s or '03' in s:
                s = s.replace('01', '30', 1)
                s = s.replace('02', '101', 1)
                s = s.replace('03', '202', 1)
            if s.count('1') == 15 and s.count('2') == 10 and s.count('3') == 60:
                print(a)

#Дана программа для редактора:
# НАЧАЛО
# ПОКА НЕ нашлось (00)
# заменить (01, 210)
# заменить (02, 320)
# заменить (03, 3012)
# конец пока
# Известно, что исходная строка начиналась с нуля и заканчивалась нулём, а между ними содержала только единицы, двойки и тройки. 
# После выполнен данной программы получилась строка, содержащая 23 единицы, 48 двоек и 41 тройку. Сколько цифр было в исходной строке?

for a in range(1, 50):
    for b in range(1, 50):
        for c in range(1, 50):
            s = '0' + a *'1' + b * '2' + c * '3' + '0'
            while '00' not in s:
                s = s.replace('01', '210', 1)
                s = s.replace('02', '320', 1)
                s = s.replace('03', '3012', 1)
            if s.count('1') == 23 and s.count('2') == 48 and s.count('3') == 41:
                print(a + b + c + 2)
                break


#АКТУАЛЬНООООО АКТУАЛЬНООООО АКТУАЛЬНООООО АКТУАЛЬНООООО АКТУАЛЬНООООО АКТУАЛЬНОООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООООО

# Дана программа для Редактора:
# НАЧАЛО
# ПОКА нашлось (52) ИЛИ нашлось (1122) ИЛИ нашлось (2222)
# ЕСЛИ нашлось(52)
# ТО заменить (52, 11)
# конецесли
# ЕСЛИ нашлось(2222)
# ТО заменить (2222, 5)
# конецесли
# ЕСЛИ нашлось(1122)
# ТО заменить (1122, 25)
# конец пОка
# конец
# На вход приведённой выше программе поступает строка, начинающаяся с цифры 5, а затем содержащая п цифр 2 (3 < n < 10 000).
# Определите наименьшее значение п, при котором сумма цифр в строке, получившейся в результате выполнения программы, равна 64.


for n in range(4, 10000):
    s = '5' + n * '2'
    while '52' in s or '1122' in s or '2222' in s:
        if '52' in s:
            s = s.replace('52', '11', 1)
        if '2222' in s:
            s = s.replace('2222', '5', 1)
        if '1122' in s:
            s = s.replace('1122', '25', 1)
    if sum(map(int, s)) == 64:
        print(n)
        break

#Дана программа для Редактора:
# ПОКА нашлось (52) ИЛИ нашлось (2222) ИЛИ нашлось (1122)
# ЕСЛИ нашлось (52)
# ТО заменить (52, 11)
# КОНЕЦЕСЛИ
# ЕСЛИ нашлось (2222)
# ТО заменить (2222, 5)
# ЕСЛИ нашлось (1122)
# ТО заменить (1122, 25)
# КОНЕЦЕСЛИ
# конец пока
# КОНЕЦ
# На вход приведённой выше программе поступает строка, начинающаяся с цифры «5», а затем содержащая n цифр «2» (3 < n < 10 000).
# Определите наименьшее значение п, при котором сумма цифр в строке, получившейся в результате выполнения программы, оканчивается на 7.

for n in range(4, 10000):
    s = '5' + n * '2'
    while '52' in s or '1122' in s or '2222' in s:
        if '52' in s:
            s = s.replace('52', '11', 1)
        if '2222' in s:
            s = s.replace('2222', '5', 1)
        if '1122' in s:
            s = s.replace('1122', '25', 1)
    if sum(map(int, s)) % 10 == 7:
        print(n)
        break

# Дана программа для исполнителя Редактор:
# НАЧАЛО
# ПОКА НЕ нашлось (00)
# заменить (02, 101)
# заменить (11, 2)
# заменить (12, 21)
# заменить (010, 00)
# КОНЕЦ ПОКА
# КОНЕЦ
# Известно, что исходная строка содержала ровно два нуля - на первом и на последнем месте, а также одинаковое количество единиц и двоек, расположенных в произвольном порядке. 
# При этом всего в строке было более 200 цифр. После выполнения данной программы получилась строка, сумма цифр которой является простым числом и одновременно палиндромом. 
# Какое наименьшее количество единиц могло быть в исходной строке?

def is_prime(x): #проверка на простоту числа 
    return x > 1 and all(x % d != 0 for d in range(2, round(x**0.5)+1))

#палиндром это строка, которая читается с обоих сторон одинакова
for n in range(100, 1000): # было более 200 цифр, oдинаковое количество единиц и двоек поэтому 100
    s = '0' + n*'1' + n *'2' + '0'
    while '00' not in s:
        s = s.replace('02', '101', 1)
        s = s.replace('11', '2', 1)
        s = s.replace('12', '21', 1)
        s = s.replace('010', '00', 1)
    summ = sum(map(int, s))
    if is_prime(summ) and str(summ) == str(summ)[::-1]:
        print(n)
        break

#Дана программа для исполнителя Редактор:
# ПОКА нашлось(01) ИЛИ нашлось(02)
# заменить(02, 110)
# заменить(01, 2120)
# На вход программе поступает строка длиной не менее 79 символов, первый из которых - цифра 0, а остальные - цифры 1 и 2. 
# После выполнения программы получилась строка, сумма цифр которой - число-палиндром (читается одинаково слева направо и справа налево).
# Чему равна наименьшая возможная сумма цифр в исходной строке?

res = []
for n in range(79, 200):
    for n1 in range(1, n):
        n2 = n - 1 - n1
        s = '0' + n1 * '1' + n2 * '2'
        while '01' in s or '02' in s:
            s = s.replace('02', '110', 1)
            s = s.replace('01', '2120', 1)
        summ = str(sum(map(int, s)))
        if summ == summ[::-1]:
            res.append(n1+ n2*2)
print(min(res))


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#13 задание егэ по информатике
#В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, 
#какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу узла в этой сети. 
# Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.
#Сеть задана IP-адресом 192.168.32.160 и маской сети 255.255.255.240. Сколько в этой сети IP-адресов, для которых сумма единиц в двоичной записи IP-адреса чётна?

#В ответе укажите только число.

from ipaddress import *

def F(ip):
    res=''
    a = str(ip).split('.')
    for s in a:
        res = res + format(int(s), 'b').zfill(8)
    return res

k=0

net = ip_network('192.168.32.160/255.255.255.240', 0)

for ip in net:
    if F(ip).count('1')%2==0:
        k += 1

print(k)



#В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети,
#  а какая – к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.

#Сеть задана IP-адресом 253.112.169.12 и маской сети 255.255.254.0. 
# Сколько в этой сети IP-адресов, для которых в двоичной записи IP-адреса
#  суммарное количество единиц в правых двух байтах не менее суммарного количества единиц в левых двух байтах.

from ipaddress import *

def F(ip):
    res=''
    a = str(ip).split('.')
    for s in a:
        res = res + format(int(s), 'b').zfill(8)
    return res

k=0

net = ip_network('253.112.169.12/255.255.254.0', 0)

for ip in net:
    s = F(ip)
    if s[:16].count('1') <= s[16:].count('1'):
        k += 1

print(k)

#Задача (Минимальный байт маски)
#В терминологии сетей TCP/IP маской сети называется двоичное число, определяющее, какая часть IP-адреса узла сети относится к адресу сети,
#  а какая - к адресу самого узла в этой сети. Обычно маска записывается по теме же правилам, что и IP-адрес - в виде четырёх байтов,
#  причём каждый байт записывается в виде десятичного числа. При этом в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого разряда - нули. 
# Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
#Например, если IP-адрес узла равен 231.32.255.131, а маска равна 255.255.240.0, то адрес сети равен 231.32. 240.0.
#Для узла с IP-адресом 111.81.88.168 адрес сети равен 111.81.88.160.
#Найдите наименьшее значение последнего байта маски. Ответ запишите в виде десятичного числа.

from ipaddress import *

ip = ip_address('111.81.88.168')

for mask in range(31):
    net = ip_network(f'{ip}/{mask}', 0)
    if net[0] < ip < net[-1]:
        print(net, net.netmask)


#Задача (Максимальное количество единиц в маске)
#В терминологии сетей TCP/IP маской сети называется двоичное число, определяющее, какая часть IP-адреса узла сети относится к адресу сети,
#  а какая – к адресу самого узла в этой сети. При этом в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места – нули. 
# Обычно маска записывается по тем же правилам, что и IP-адрес – в виде четырёх байтов, причём каждый байт записывается в виде десятичного числа.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.

#Например, если IP-адрес узла равен 231.32.255.131, а маска равна 255.255.240.0, то адрес сети равен 231.32.240.0.
#Для узла с IP-адресом 93.138.70.47 адрес сети равен 93.138.64.0. 
# Каково наибольшее возможное общее количество единиц во всех четырёх байтах маски? Ответ запишите в виде десятичного числа.
from ipaddress import *

ip = ip_address('93.138.70.47')

for mask in range(31):
    net = ip_network(f'{ip}/{mask}', 0)
    if net[0] < ip < net[-1]:
        print(net)

#Задача (Количество адресов компьютеров)
#В терминологии сетей TCP/IP маской подсети называется 32-разрядное двоичное число, определяющее, какие именно разряды IP-адреса компьютера
#  являются общими для всей подсети – в этих разрядах маски стоит 1. Обычно маски записываются в виде четверки десятичных чисел – по тем же правилам, что и IP-адреса. 
#Для некоторой подсети используется маска 255.255.248.0. 
# Сколько различных адресов компьютеров допускает эта маска?
from ipaddress import *
net = ip_network('0.0.0.0/255.255.248.0')
print(net.num_addresses - 2)

#Задача (Количество масок)
#В терминологии сетей TCP/IP маска сети – это двоичное число, меньшее 232; в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места нули. 
# Маска определяет, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу самого узла в этой сети.
#  Обычно маска записывается по тем же правилам, что и IP-адрес – в виде четырёх байт, причём каждый байт записывается в виде десятичного числа.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
#Для узла c IP-адресом 175.122.80.13 адрес подсети равен 175.122.80.0. 
#Сколько существует различных возможных значений маски, если известно, что в этой сети не менее 60 узлов? Ответ запишите в виде десятичного числа.
from ipaddress import *

ip = ip_address('175.122.80.13')

for mask in range(31):
    net = ip_network(f'{ip}/{mask}', 0)
    if net[0] < ip < net[-1]:
        print(net)
#or 
from ipaddress import *

ip = ip_address('175.122.80.13')

for mask in range(31):
    net = ip_network(f'{ip}/{mask}', 0)
    if net[0] < ip < net[-1]:
        if net.num_addresses - 2 >= 60:
            print(net)

#Задача (Порядковый номер компьютера)
#Маской подсети называется 32-разрядное двоичное число, которое определяет, какая часть IP-адреса компьютера относится к адресу сети, а какая часть IP-адреса определяет адрес компьютера в подсети. 
# В маске подсети старшие биты, отведенные в IP-адресе компьютера для адреса сети, имеют значение 1; младшие биты, отведенные в IP-адресе компьютера для
# адреса компьютера в подсети, имеют значение 0.

#Если маска подсети 255.255.255.224 и IP-адрес компьютера в сети 162.198.0.157, то порядковый номер компьютера в сети равен_____
#Решение:
#В этой задаче ключевой фразой является: "порядковый номер компьютера". Нужно знать, как решать данную тренировочную задачу из ЕГЭ по информатике.

#Первые 3 слева байты маски равны 255 (111111112), значит, они не участвуют в решении этой задачи.

#Мы фокусируем внимание на том байте IP-адреса, под которым байт маски имеет не все единицы в своих разрядах.

##Переведём числа 224 и 157 в двоичную систему.

#Число 224 в двоичной системе равно 111000002.

#Число 157 в двоичной системе равно 100111012.

#Запишем друг под другом данные числа в двоичной системе

#ЕГЭ по информатике - Задание 13 (Порядковый номер компьютера)

#Выписываем ту часть IP-адреса, которая находится над нулями.

#Нужно перевести это двоичное число 111012 в десятичную систему, это и будет ответ. Получается число 29

#Примечание:
#Предположим IP адрес будет 162.198.157.10, а маска подсети 255.255.224.0, тогда запишем байты IP-адреса, а под ними байты маски:

#10011101 00001010
#11100000 00000000
#о берём всё равно ту часть ip-адреса, которая находится над нулями! Не ограничиваемся 8-ю разрядами!
#11101000010102 = 7434
#Данную задачу лучше решать вручную без использования ipaddress.

#Задача (Параметр A в маске)
#В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, 
# а какая – к адресу узла в этой сети. 
#Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.

#Сеть задана IP-адресом 255.211.33.160 и маской сети 255.255.A.0, где A - некоторое допустимое для записи маски число. 
# Определите минимальное значение A, для которого для всех IP-адресов этой сети в двоичной записи IP-адреса суммарное количество единиц в левых двух байтах не менее 
# суммарного количества единиц в правых двух байтах.
from ipaddress import *

def F(ip):
    res=''
    a = str(ip).split('.')
    for s in a:
        res = res + format(int(s), 'b').zfill(8)
    return res

for i in range(9):

    A_bin = i * '1'

    while len(A_bin)<8:
        A_bin = A_bin + '0'

    A = int(A_bin, 2)
    
    net = ip_network(f'255.211.33.160/255.255.{A}.0', 0) #Заменять тут ответ будет первое число
    flag = 1
    for ip in net:
        s = F(ip)
        if s[:16].count('1') < s[16:].count('1'):
            flag=0
            break
    if flag==1:
        print(A)


#Задача (Параметр A в IP-адресе)
#В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, 
##какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу узла в этой сети. 
#Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.
#Сеть задана IP-адресом 32.0.A.5, где A - некоторое допустимое для записи IP-адреса число, и маской сети 255.255.240.0. Определите минимальное значение A, 
# для которого для всех IP-адресов
#этой сети в двоичной записи IP-адреса суммарное количество единиц в левых двух байтах не более суммарного количества единиц в правых двух байтах.

from ipaddress import *

def F(ip):
    res=''
    a = str(ip).split('.')
    for s in a:
        res = res + format(int(s), 'b').zfill(8)
    return res

for A in range(256):
    
    net = ip_network(f'32.0.{A}.5/255.255.240.0', 0) #Заменять тут
    flag = 1
    for ip in net:
        s = F(ip)
        if s[:16].count('1') > s[16:].count('1'):
            flag=0
            break
    if flag==1:
        print(A)
        break
#Ещё одна такакя задача
def count_ones(ip):
    binary_ip = ''.join(format(int(octet), '08b') for octet in ip.split('.'))
    return binary_ip.count('1')

def find_min_a():
    a = 0
    while True:
        ip = f'192.214.{a}.184'
        mask = '255.255.255.224'
        network = '.'.join(str(int(ip_octet) & int(mask_octet)) for ip_octet, mask_octet in zip(ip.split('.'), mask.split('.')))
        if count_ones(network) > 15:
            return a
        a += 1

print(find_min_a())



#По заданным IP-адресу узла сети и маске определите адрес сети:
# IP-адрес: 135.12.171.214
# Маска: 255.255.248.0
# При записи ответа выберите из приведенных в таблице чисел 4 фрагмента четыре элемента IP-адреса и запишите в нужном порядке соответствующие им буквы без точек.

from ipaddress import *

print(ip_network('135.12.171.214/255.255.248.0', False))


# Для узла с IP-адресом 98.162.71.123 адрес сети равен 98.162.71.96. Чему равен последний (самый правый) байт маски? Ответ запишите в виде десятичного числа.
for m in range(33):
    net = ip_network(f'98.162.71.123/{m}', 0)
    if '98.162.71.96' in str(net):
        print(net.netmask)


#Для узла с IP-адресом 119.167.50.77 адрес сети равен 119.167.48.0. 
# Чему равно наименьшее возможное значение третьего слева байта маски? Ответ запишите в виде десятичного числа.

from ipaddress import *

for m in range(33):
    net = ip_network(f'119.167.50.77/{m}', 0)
    if '119.167.48.0' in str(net):
        print(net.netmask)
        break


#Для узла с IP-адресом 215.181.200.27 адрес сети равен 215.181.192.0.
#  Чему равно наибольшее возможное значение третьего слева байта маски? 
# Ответ запишите в виде десятичного числа.


from ipaddress import *
for m in range(32, -1, -1):
    net = ip_network(f'215.181.200.27/{m}', 0)
    if '215.181.192.0' in str(net):
        print(net.netmask)

#Для узла с IP-адресом 93.138.70.47 адрес сети равен 93.138.64.0. 
# Каково наименьшее возможное общее количество единиц во всех четырёх байтах маски?
#  Ответ запишите в виде десятичного числа.

from ipaddress import *

for m in range(33):
    net = ip_network(f'93.138.70.47/{m}', 0)
    if '93.138.64.0' in str(net):
        print(m) #наименьшее возможное общее количество единиц
        break

#(М. Ишимов) В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети,
#  а какая - к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.
#Для узла с IP-адресом 193.22.209.132 адрес сети равен 193.22.209.128. Каково наименьшее возможное количество нулей в двоичной записи маски?

from ipaddress import *
for m in range(32, -1,-1):
    net = ip_network(f'193.22.209.132/{m}', 0)
    if '193.22.209.128' in str(net):
        print(32-m) #наименьшее возможное количество нулей
        break



#Два узла, находящиеся в одной сети, имеют IP-адреса 115.127.30.120 и 115.127.151.120.
#  Укажите наибольшее возможное значение третьего слева байта маски сети. Ответ запишите в виде десятичного числа.

from ipaddress import *
for m in range(32, -1, -1):
    net = ip_network(f'115.127.30.120/{m}', 0)
    net2 = ip_network(f'115.127.151.120/{m}', 0)
    if str(net) == str(net2):
        print(net.netmask)
        break


#Узлы с IP-адресами 98.162.71.151 и 98.162.71.155 находятся в одной сети. Чему равно наибольшее количество возможных единиц в маске этой сети?

from ipaddress import *

for m in range(32, -1, -1):
    net = ip_network(f'98.162.71.151/{m}', 0)
    net2 = ip_network(f'98.162.71.155/{m}', 0)
    if str(net) == str(net2):
        print(m)
        break


#Два узла, находящиеся в разных подсетях, имеют IP-адреса 10.96.180.231 и 10.96.140.118. 
# В масках обеих подсетей одинаковое количество единиц. 
# Найдите наибольшее возможное количество нулей в двоичной записи маски подсет
from ipaddress import *

for m in range(33):
    net = ip_network(f'10.96.180.231/{m}', 0)
    net2 = ip_network(f'10.96.140.118/{m}', 0)
    if str(net) != str(net2):
        print(32-m)
        break

## В терминологии сетей ТСР/IP маской подсети называется 32-разрядное двоичное число, определяющее, 
# какие именно разряды IP-адреса компьютера являются общими для всей подсети, - в этих разрядах маски стоит 1. 
# Обычно маски записываются в виде четверки десятичных чисел - по тем же правилам, что и IP-адреса. Для некоторой подсети используется маска 255.255.255.128. 
# Сколько различных адресов компьютеров теоретически допускает эта маска, если два адреса (адрес сети и широковещательный) не используют?

from ipaddress import *
net = ip_network('0.0.0.0/255.255.255.128', 0)
print(net.num_addresses-2)


#Маской подсети называется 32-разрядное двоичное число, которое определяет, какая часть IP-адреса компьютера относится к адресу сети,
#  а какая часть IP-адреса определяет адрес компьютера в подсети. В маске подсети старшие биты, отведенные в IP-адресе компьютера для адреса сети, имеют значение 1; 
# младшие биты, отведенные в IP-адресе компьютера для адреса компьютера в подсети, имеют значение 0.
# Если маска подсети 255.255.248.0 и IP-адрес компьютера в сети 112.154.133.208, то номер компьютера в сети равен

from ipaddress import *
net = ip_network('112.154.133.208/255.255.248.0', 0)
k = 0 
for ip in net:
    if ip == ip_address('112.154.133.208'):
        print(k)
    k += 1

## В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети а какая - к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и его маске. Сеть задана IP-адресом 172.16.168.0 и маской сети 255.255.248.0.
#  Сколько в этой сети IP-адресов, для которых количество единиц в двоичной записи IP- адреса не кратно 5?

from ipaddress import *
net = ip_network('172.16.168.0/255.255.248.0', 0)
k = 0 
for ip in net:
    ip_bin = bin(int(ip))[2:].zfill(32)
    if ip_bin.count('1') % 5 != 0:
        k += 1
print(k)

#(К. Багдасарян) В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает,
#  какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети. 
# Сеть задана IP-адресом 202.75.38.160 и маской сети 255.255.255.240. 
# Сколько в этой сети IP-адресов, у которых в двоичной записи IP-адреса имеется сочетание трех подряд идущих единиц? В ответе укажите только число.

from ipaddress import *
net = ip_network('202.75.38.160/255.255.255.240', 0)
k = 0 
for ip in net:
    ip_bin = bin(int(ip))[2:].zfill(32)
    if '111' in ip_bin:
        k += 1
print(k)

# (В. Зарянкин) В терминологии сетей ТСP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и его маске. 
# Сеть задана IP-адресом 102.141.0.0 и сетевой маской 255.255.192.0.
#  Сколько в этой сети IP-адресов, для которых количество единиц в двоичной записи IP-адреса кратно 7, а сама двоичная запись оканчивается на 1011?

from ipaddress import *
net = ip_network('102.141.0.0/255.255.192.0', 0)
k = 0 
for ip in net:
    ip_bin = bin(int(ip))[2:].zfill(32)
    if ip_bin.count('1') % 7 == 0 and ip_bin[-4:] == '1011':
        k += 1
print(k)


#(М. Ишимов) В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети. 
# Сеть задана IP-адресом 186.135.80.0 и маской сети 255.255.252.0. Сколько в этой сети IP-адресов, 
# для которых в двоичной записи IP-адреса суммарное количество единиц в левых двух байтах больше суммарного количества единиц в правых двух байтах?

from ipaddress import *
net = ip_network('186.135.80.0/255.255.252.0', 0)
k = 0 
for ip in net:
    ip_bin = bin(int(ip))[2:].zfill(32)
    if ip_bin[:16].count('1') > ip_bin[16:].count('1'):
        k += 1
print(k)


#В терминологии сетей ТСР/IP маска сети - это двоичное число, меньшее 282; в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места нули.
#  Маска определяет, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу самого узла в этой сети. Обычно маска записывается по тем же правилам, что и IP-адрес - в виде четырёх байт, причём каждый байт записывается в виде десятичного числа. 
# Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
#Для узла с IP-адресом 175.122.80.13 адрес подсети равен 175.122.80.0. 
# Сколько существует различных возможных значений маски, если известно, что в этой сети не менее 60 узлов? Ответ запишите в виде десятичного числа.


from ipaddress import *
k = 0 
for m in range(33):
    net = ip_network(f'175.122.80.13/{m}', 0)
    if '175.122.80.0' in str(net):
        if net.num_addresses -2 >= 60:
            k += 1
print(k)


#В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.
#  Узлы с IP-адресами 154.63.206.129 и 154.63.100.75 находятся в одной сети.
#  Укажите наименьшее возможное количество принадлежащих этой сети IP- адресов, в двоичной записи которых чётное число единиц.

from ipaddress import *


for m in range(32, -1, -1):
    net = ip_network(f'154.63.206.129/{m}', 0)
    net2 = ip_network(f'154.63.100.75/{m}', 0)
    if net == net2:
        k = 0
        for ip in net:
            if bin(int(ip))[2:].zfill(32).count('1') % 2 == 0:
                k+=1
        print(k)
        break

#В терминологии сетей ТСР/IP маской сети называется двоичное число, определяющее, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу самого узла в этой сети. При этом в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места нули. Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
#Например, если IP-адрес узла равен 231.32.255.131, а маска равна 255.255.240.0, то адрес сети равен 231.32.240.0.
#Известно, что в составе сети, которой принадлежит IP-адрес 149.238.225.115, есть узел, в IP-адресе которого первый байт совпадает с четвёртым, а второй - с третьим.
#Укажите наименьшее возможное количество принадлежащих этой сети IP- адресов, в двоичной записи которых ровно 15 единиц.

from ipaddress import *


for m in range(32, -1, -1):
    net = ip_network(f'149.238.225.115/{m}', 0)
    k = 0
    if ip_address('149.238.238.149') in net:
        for ip in net:
            if bin(int(ip))[2:].zfill(32).count('1') == 15:
                k+=1
        print(k)
        break


#*(М. Ишимов) В терминологии сетей ТСР/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети.
#  Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети. 
# Сеть, в которой содержится узел с IP-адресом 117.157.2.8, задана маской сети 255.255.А.О,
#  где А - некоторое допустимое для записи маски число.
#  Определите минимальное значение А, для которого для всех IP- адресов этой сети в двоичной записи IP-адреса
#  суммарное количество единиц в левых двух байтах не менее суммарного количества единиц в правых двух байтах.

from ipaddress import *

for a in range(256):
    try:
        net = ip_network(f'117.157.2.8/255.255.{a}.0', 0)
        if all((bin(int(ip))[2:].zfill(32)[:16].count('1')) >= (bin(int(ip))[2:].zfill(32)[16:].count('1')) for ip in net):
            print(a)
            break
    except: pass


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

#Задача 14 (ЕГЭ по информатике, 2024)
#Значение арифметического выражения 3100 - x, где х — целое положительное число, не превышающее 2030, записали в троичной системе счисления. 
# Определите наибольшее значение х, при котором в троичной записи числа, являющегося значением данного арифметического выражения, содержится ровно пять нулей.
#В ответе запишите число в десятичной системе счисления.
for x in range(1, 2031):
    
    f = 3**100 - x
    #Счётчик нулей в троичной системе
    k=0

    #Перебираем цифры в троичной системе
    while f>0:
        if f%3==0:
            k += 1
        f = f // 3   
    
    if k==5:
        print(x)

#Задача (Классика)
#Значение выражения 536 + 524 - 25 записали в системе счисления с основанием 5. Сколько цифр "4" содержится в этой записи?
f = 5**36 + 5**24 - 25
k=0

while f>0:
    if f%5==4:
        k += 1
    f = f // 5

print(k)

#Задача (Классика, количество цифр, превышающих 9)
#Определите количество цифр с числовым значением, превышающим 9, в 27-ричной записи числа, заданного выражением:
#  2∙7292014 + 2∙2432016 - 2∙812018 + 2∙272020 - 2∙92022 - 2024.
f = 2*729**2014 + 2*243**2016 - 2*81**2018 + 2*27**2020 - 2*9**2022 - 2024
k=0

while f>0:
    if f%27 > 9:
        k += 1
    f = f // 27

print(k)

#Задача (Классика, сумма цифр)
#Значение арифметического выражения 51∙712 - 73 - 22 записали в системе счисления с основанием 7. 
# В этой записи найдите сумму цифр с числовым значением, превышающим 3.

f = 51*7**12 - 7**3 - 22
sm = 0

while f>0:
    if f%7 > 3:
        sm = sm + (f%7)
    f = f // 7

print(sm)

#Задача (Классика, второй тип)
#В выражении 1xBAD16 + 2CxFE16 x обозначает некоторую цифру из алфавита шестнадцатеричной системы счисления. 
# Определите наименьшее значение x, при котором значение данного выражения кратно 15. 
# Для найденного x вычислите частное от деления данного выражения на 15 и запишите его в ответе в десятичной системе счисления.

for x in range(0, 16):
    a=13*16**0 + 10*16**1 + 11*16**2 + x*16**3 + 1*16**4
    b=14*16**0 + 15*16**1 + x*16**2 + 12*16**3 + 2*16**4
    if (a+b)%15==0:
        print(x, (a+b)//15)


def find_x():
    x = 0
    while True:
        # Преобразуем шестнадцатеричные числа в десятичные
        num1 = int('1' + hex(x)[2:] + 'BAD', 16)
        num2 = int('2C' + hex(x)[2:] + 'FE', 16)
        # Проверяем, является ли сумма чисел кратной 15
        if (num1 + num2) % 15 == 0:
            # Если да, возвращаем частное от деления суммы на 15
            return (num1 + num2) // 15
        # Если нет, увеличиваем значение x на 1 и повторяем цикл
        x += 1

# Выводим результат на экран
print(find_x())

#Задача(Классика, второй тип, закрепление)
#Операнды арифметического выражения записаны в системе счисления с основанием 17:
#9759x17 + 3x10817
#В записи чисел переменной x обозначена неизвестная цифра из алфавита 17-ричной системы счисления. 
#Определите наименьшее значение x, при котором значение данного арифметического выражения кратного 11. 
# Для найденного значения x вычислите частное от деления значения арифметического выражения на 11 и укажите его в ответе в десятичной системе счисления. 
# Основание системы счисления в ответе указывать не нужно.
for x in range(0, 17):
    a=x*17**0 + 9*17**1 + 5*17**2 + 7*17**3 + 9*17**4
    b=8*17**0 + 0*17**1 + 1*17**2 + x*17**3 + 3*17**4
    if (a+b)%11==0:
        print(x, (a+b)//11)

def find_x():
    x = 0
    while True:
        # Преобразуем числа из 17-ричной системы счисления в десятичную
        num1 = int('9759' + str(x), 17)
        num2 = int('3' + str(x) + '108', 17)
        # Проверяем, является ли сумма чисел кратной 11
        if (num1 + num2) % 11 == 0:
            # Если да, возвращаем частное от деления суммы на 11
            return (num1 + num2) // 11
        # Если нет, увеличиваем значение x на 1 и повторяем цикл
        x += 1

# Выводим результат на экран
print(find_x())



#Задача (Классика, второй тип, две переменные)
#Числа M и N записаны в системах счисления с основаниями 15 и 13 соответственно.

#M = 2y23x515, N = 67x9y13
#В записи чисел переменными x и y обозначены допустимые в данных системах счисления неизвестные цифры. 
#Определите наименьшее значение натурального числа A, при котором существуют такие x, y, что M + A кратно N.
for A in range(1, 5000):
    for x in range(0, 13):
        for y in range(0, 13): 
            M=5*15**0 + x*15**1 + 3*15**2 + 2*15**3 + y*15**4 + 2*15**5
            N=y*13**0 + 9*13**1 + x*13**2 + 7*13**3 + 6*13**4
            if (M+A)%N==0:
                print(A)



#Задача (Уравнение)
#Чему равно наименьшее основание позиционной системы счисления x, при котором 225x = 405y? Ответ записать в виде целого числа.
for x in range(2, 1000):
    for y in range(2, 1000):
        a = 5*x**0 + 2*x**1 + 2*x**2
        b = 5*y**0 + 0*y**1 + 4*y**2
        if a == b: 
            print(x)


#Операнды арифметического выражения записаны в системе счисления с основание 18:
#11Hx05 18 + 3Fx54x8 18 + Gxxx9 18
#где x неизвестная цифра из алфавита 18-ричной системы счисления. Найдите наименьшее значение x при котором результат выражения кратен 14.
#  Для найденного x вычислите частное от деления значения арифметического выражения на 14 и укажите его в ответе в десятичной системе счисления.

#Основание системы счисления указывать не нужно.
for x in '0123456789ABCDEFGH':
    a = int(f'11H{x}05', 18) + int(f'3F{x}54{x}8', 18) + int(f'G{x}{x}{x}9', 18)
    if a % 14 == 0:
        print(x, a // 14)


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

#Задние 15 егэ по информатике

#Какое количество натуральных чисел удовлетворяет логическому условию:
#Задача (Неравенство, одна переменная)
#¬(X2 ≥ 9) ∨ ¬((X < 7) ∨ (X ≥ 10)) ?
k=0
for x in range(1, 1000):
    if not(x**2 >= 9) or not((x < 7) or (x>=10)):
        k = k + 1
        
print(k)

#Задача (Неравенство, две переменные)
#Для какого наибольшего целого неотрицательного числа A выражение
#(x ≥ A) ∨ (y ≥ A) ∨ (x * y ≤ 205)
#tождественно истинно, т.е. принимает значение 1 при любых целых положительных x и y ?
for A in range(0, 300):
    k=0
    for x in range(1, 301):
        for y in range(1, 301):
            if (x >= A) or (y >= A) or (x * y <= 205):
                k=k+1
    if k==300*300:
        print(A)

#Задача (Функция ДЕЛ)
#Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m». Для какого наибольшего натурального числа А формула
#¬ДЕЛ(x, А) → (ДЕЛ(x, 6) → ¬ДЕЛ(x, 9))
#тождественно истинна (то есть принимает значение 1 при любом натуральном значении переменной x)?

def D(n, m):
    if n%m==0:
        return True
    else:
        return False

for A in range(1, 1000):
    k=0
    for x in range(1, 1001):
        if D(x, A) or (not(D(x, 6)) or not(D(x, 9))):
            k=k+1
    if k==1000:
        print(A)

#Задача (Поразрядная конъюнкция)
#Обозначим через m&n поразрядную конъюнкцию неотрицательных целых чисел m и n. Так, например, 14&5 = 11102 & 01012 = 4
#Для какого наименьшего неотрицательного целого числа A формула
#x&51 ≠ 0 → (x&A = 0 → x&25 ≠ 0)
#тождественно истинна (то есть принимает значение 1 при любом неотрицательном целом значении переменной x)?

for A in range(0, 1000):
    k=0
    for x in range(0, 1000):
        if x&51==0 or (x&A!=0 or x&25!=0):
            k=k+1

    if k==1000:
        print(A)

# Задача (Отрезки, минимальная длина)
# На числовой прямой даны отрезки P=[5, 13] и Q=[8, 19]. 
# Укажите наименьшую возможную длину такого отрезка A, что формула (¬(x ∈ P) → (x ∈ Q)) → (x ∈ A ) верна при любых значениях x.

# Функция F проверяет, принадлежит ли точка x отрезку [a, b]
def F(a, b, x):
   if a <= x <= b:
       return True
   else:
       return False

# Инициализация минимальной длины отрезка A
mn = 10**9

# Цикл по всем возможным значениям границ отрезка A
for a in range(0, 100):
   for b in range(a, 100):
       # Счетчик количества точек, удовлетворяющих условию
       k = 0
       # Цикл по всем возможным значениям x
       for i in range(2, 200):
           x = i / 2
           # Проверка условия (¬(x ∈ P) → (x ∈ Q)) → (x ∈ A )
           if not((F(5, 13, x) or F(8, 19, x))) or F(a, b, x):
               k += 1
       # Если все точки удовлетворяют условию, то обновляем минимальную длину отрезка A
       if k == 198:
           mn = min(mn, b - a)

# Выводим минимальную длину отрезка A
print(mn)

#
#
#


#
# Задача (Отрезки, максимальная длина)
# На числовой прямой даны два отрезка: P = [43; 49] и Q = [44; 53]. Укажите наибольшую возможную длину такого отрезка A, что формула
# ((x ∈ A) → (x ∈ P)) ∨ (x ∈ Q)
# тождественно истинна, то есть принимает значение 1 при любых x.

# Функция F проверяет, принадлежит ли точка x отрезку [a, b]
def F(a, b, x):
   if a <= x <= b:
       return True
   else:
       return False

# Функция F2 проверяет, принадлежит ли точка x интервалу (a, b)
def F2(a, b, x):
   if a < x < b:
       return True
   else:
       return False

# Инициализация максимальной длины отрезка A
mx = 0

# Цикл по всем возможным значениям границ отрезка A
for a in range(0, 100):
   for b in range(a, 100):
       # Счетчик количества точек, удовлетворяющих условию
       k = 0
       # Цикл по всем возможным значениям x
       for i in range(2, 200):
           x = i / 2
           # Проверка условия ((x ∈ A) → (x ∈ P)) ∨ (x ∈ Q)
           if (not(F2(a, b, x)) or F(43, 49, x)) or F(44, 53, x):
               k += 1
       # Если все точки удовлетворяют условию, то обновляем максимальную длину отрезка A
       if k == 198:
           mx = max(mx, b - a)

# Выводим максимальную длину отрезка A
print(mx)


# Задача (Гибрид, ЕГЭ по информатике 2024)
# Обозначим через ДЕЛ(n, m) утверждение «натуральное число n делится без остатка на натуральное число m». 
# Пусть на числовой прямой дан отрезок B = [70, 90].
# Для какого наибольшего натурального числа А логическое выражение ДЕЛ(x, А) \/ ((x ∈ B) → ¬ДЕЛ(x, 22)) истинно (т.е. принимает значение 1) 
# при любом целом положительном значении переменной х?

# Функция D проверяет, делится ли число n на число m без остатка
def D(n, m):
   if n % m == 0:
       return True
   else:
       return False

# Функция F проверяет, принадлежит ли точка x отрезку [a, b]
def F(a, b, x):
   if a <= x <= b:
       return True
   else:
       return False

# Цикл по всем возможным значениям А
for A in range(1, 1000):
   # Счетчик количества точек, удовлетворяющих условию
   k = 0
   # Цикл по всем возможным значениям x
   for x in range(1, 1001):
       # Проверка условия ДЕЛ(x, А) \/ ((x ∈ B) → ¬ДЕЛ(x, 22))
       if D(x, A) or (not(F(70, 90, x)) or not(D(x, 22))):
           k += 1
   # Если все точки удовлетворяют условию, то выводим значение А
   if k == 1000:
       print(A)


# Задача (Неравенство, две переменные, закрепление)
# Для какого наибольшего целого неотрицательного числа A выражение
# (x < A) ∧ (y < A) ∧ (x * y > 603)
# тождественно ложно, т.е. принимает значение 0 при любых целых положительных x и y ?

# Цикл по всем возможным значениям A
for A in range(0, 300):
   # Счетчик количества точек, удовлетворяющих условию
   k = 0
   # Цикл по всем возможным значениям x и y
   for x in range(1, 301):
       for y in range(1, 301):
           # Проверка условия (x < A) ∧ (y < A) ∧ (x * y > 603)
           if not((x < A) and (y < A) and (x * y > 603)):
               k += 1
   # Если все точки удовлетворяют условию, то выводим значение A
   if k == 300 * 300:
       print(A)

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

#Задача (Лёгкая)
#Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#F(n) = 1 при n = 1;
#F(n) = n + F(n − 1), если n – чётно,
#F(n) = 3 × F(n − 2), если n > 1 и при этом n – нечётно.
#Чему равно значение функции F(25)?
# Сама функция
def F(n):
    if n==1: return 1
    if n%2==0: return n+F(n-1)
    if n>1 and n%2!=0: return 3*F(n-2)
    
# Основная часть программы
print(F(25))
#
#
#
#
#Задача (Продолжаем подготовку)
#Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
#F(1) = 1
#F(2) = 3
#F(n) = F(n–1) * n + F(n–2) * (n – 1) , при n > 2
#Чему равно значение функции F(8)? В ответе запишите только натуральное число.

# Сама функция
def F(n):
    if n==1: return 1
    if n==2: return 3
    if n>2: return F(n-1)*n + F(n-2)*(n-1)
    
# Основная часть программы
print(F(8))


#
#
#
#
#

#Задача(Две функции)
#Алгоритм вычисления значения функций F(n) и G(n), где n — натуральное число, задан следующими соотношениями:
#F(n) = 0, если n <= 2,
#F(n) = G(n - 2), если n > 2
# G(n) = 0, n <= 1,
# G(n) = F(n - 1) + n, если n > 1
# Чему равно значение функции F(8)? В ответе запишите только натуральное число.'

# Сами функции
def F(n):
    if n<=2: return 0
    if n>2: return G(n-2)

def G(n):
    if n<=1: return 0
    if n>1: return F(n-1)+n

# Основная часть программы
print(F(8))




# Задача (Новое веяние)
# (К. Багдасарян) Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
# F(n) = 2, если n = 1,
# F(n) = 2 · F(n – 1), если n > 1.
# Чему равно значение выражения F(1900)/2**21890 ?

from functools import lru_cache

# Используем декоратор lru_cache для кэширования результатов функции F(n)
@lru_cache(None)
def F(n):
   # Если n равно 1, то возвращаем 2
   if n == 1:
       return 2
   # Если n больше 1, то возвращаем 2 умноженное на значение функции F(n - 1)
   if n > 1:
       return 2 * F(n - 1)

# Вычисляем значения функции F(n) для всех n от 2 до 1899
for i in range(2, 1900):
   F(i)

# Выводим значение выражения F(1900)/2**21890
print(F(1900) / 2**1890)


#Задача(Новое веяние, закрепление)
# Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
# F(n) = 1 при n ≤ 2;
# F(n) = n * F(n-2), если n > 2.
# Чему равно значение выражение F(3000)/F(2996) ?

from functools import lru_cache

@lru_cache(None)
def F(n):
    if n<=2: return 1
    if n>2: return n*F(n-2)

for i in range(2, 3000):
    F(i)

print(F(3000)/F(2996))

#Задача (Вперёд к победе!)
# Алгоритм вычисления значения функции F(n), где n — натуральное число, задан следующими соотношениями:
# F(n) = 1 при n=1;
# F(n) = 2 при n=2;
# F(n) = n*(n-1) + F(n-1) + F(n-2), если n > 2.
# Чему равно значение функции F(2023) - F(2021) - 2*F(2020) - F(2019)?
from functools import lru_cache

@lru_cache(None)
def F(n):
    if n==1: return 1
    if n==2: return 2
    if n>2: return n*(n-1) + F(n-1) + F(n-2)

for i in range(2, 2023):
    F(i)

print(F(2023) - F(2021) -2*F(2020) - F(2019))


#Задача (Перебираем цикл в обратном порядке)
# Алгоритм вычисления значения функции F(n), где n – натуральное число, за-дан следующими соотношениями:
# F(n) = n при n ≥ 2025;
# F(n) = n + F(n + 2), если n < 2025.
# Чему равно значение выражения F(2020) - F(2023)?

from functools import lru_cache

@lru_cache(None)
def F(n):
    if n>=2025: return n
    if n<2025: return n+F(n+2)

for i in range(2025, 0, -1):
    F(i)

print(F(2020)-F(2023))



#Dополнительные задачи
# Задача (Количество значений
# Алгоритм вычисления значения функции F(n), где n – натуральное число, задан следующими соотношениями:
# F(n) = 2*n*n*n + 1, при n > 25
# F(n) = F(n+2) + 2*F(n+3), при n ≤ 25
# Определите количество натуральных значений n из отрезка [1; 1000], для которых значение F(n) кратно 11.

# Сама функция
def F(n):
    if n>25: return 2*n*n*n + 1
    if n<=25: return F(n+2) + 2*F(n+3)

k=0

# Перебираем диапазон
for i in range(1, 1001):
    if F(i)%11==0:
        k=k+1

print(k)


#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

# Задача (Разминка)
# В файле содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -10000 до 10000 включительно. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, в которых оба числа делятся нацело на 7, затем минимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два подряд идущих элемента последовательности. 
# Например для последовательности из пяти элементов: 7; 14; 21; -7; 4 - ответ 3 14.

# Открываем файл для чтения
f = open('17_1.txt')

# Инициализируем счетчик количества пар и минимальную сумму
k = 0
mn = 10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   # Читаем следующий элемент последовательности
   n2 = int(s)

   # Если оба числа делятся нацело на 7, то увеличиваем счетчик и обновляем минимальную сумму
   if abs(n1) % 7 == 0 and abs(n2) % 7 == 0:
       k += 1
       mn = min(mn, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и минимальную сумму
print(k, mn)


# Задача (Приём мини-счётчик)
# В файле содержится последовательность целых чисел. 
# Элементы последовательности могут принимать целые значения от -100 000 до 100 000 включительно. 
# Определите количество троек элементов последовательности, в которых хотя бы одно из чисел является четырёхзначным, 
# а сумма элементов тройки больше максимального элемента последовательности, оканчивающегося на 80. В ответе запишите количество найденных троек чисел, 
# затем минимальную из сумм элементов таких троек. В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем переменную mx для поиска максимального числа, оканчивающегося на 80
mx = -10**10

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   # Проверяем, оканчивается ли число на 80
   if abs(x) % 100 == 80:
       # Обновляем максимальное число
       mx = max(mx, x)

# Выводим максимальное число
print(mx)

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем счетчик количества троек и минимальную сумму
k = 0
mn = 10**10

# Читаем первые два элемента последовательности
n1 = int(f.readline())
n2 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n3 = int(s)

   # Приём мини-счётчик
   c = 0
   # Проверяем, является ли число четырёхзначным
   if 1000 <= abs(n1) <= 9999:
       c += 1
   if 1000 <= abs(n2) <= 9999:
       c += 1
   if 1000 <= abs(n3) <= 9999:
       c += 1

   # Основное условие
   if c >= 1 and n1 + n2 + n3 > mx:
       k += 1
       mn = min(mn, n1 + n2 + n3)

   # Обновляем значения предыдущих элементов
   n1 = n2
   n2 = n3

# Выводим количество троек и минимальную сумму
print(k, mn)



# Задача (ЕГЭ по информатике, 2024, остаток от деления)
# В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно.
# Определите количество пар последовательности, в которых остаток от деления на 55 хотя бы одного из элементов равен минимальному элементу последовательности. 
# В ответе запишите количество найденных пар, затем минимальную из сумм элементов таких пар.
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2024_2.txt')

# Инициализируем переменную mn для поиска минимального числа
mn = 10**10

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   # Обновляем минимальное число
   mn = min(mn, x)

# Выводим минимальное число
print(mn)

# Открываем файл для чтения
f = open('17_2024_2.txt')

# Инициализируем счетчик количества пар и минимальную сумму
k = 0
mn = 10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Используем приём мини-счётчик
   c = 0
   # Проверяем, равен ли остаток от деления на 55 минимальному числу
   if n1 % 55 == mn:
       c += 1
   if n2 % 55 == mn:
       c += 1

   # Основное условие
   if c >= 1:
       k += 1
       mn = min(mn, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и минимальную сумму
print(k, mn)




# В файле 17_2.txt содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -100 000 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба числа оканчиваются на одну и ту же нечётную цифру, 
# и при этом хотя бы один элемент пары больше среднего арифметического элементов последовательности. 
# В ответе запишите количество найденных пар, а затем максимальный из модулей разности элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем переменные для подсчета количества элементов и суммы элементов
k = 0
sm = 0

# Цикл по всем элементам последовательности
for s in f.readlines():
   x = int(s)
   k += 1
   sm += x

# Выводим среднее значение
print(sm / k)

#Среднее значение — это сумма элементов, делённая на их количество. Здесь нужно найти среднее значение без каких-либо условий.
#Среднее значение получается 29980.700294117647.
#Перейдём ко второму действию.

# Открываем файл для чтения
f = open('17_2.txt')

# Инициализируем счетчик количества пар и максимальную разность
k = 0
mx = -10**10

# Читаем первый элемент последовательности
n1 = int(f.readline())

# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Найдём, на что оканчиваются n1 и n2
   last1 = abs(n1) % 10
   last2 = abs(n2) % 10

   # Основное условие задачи
   if last1 % 2 == 1 and last2 % 2 == 1 and last1 == last2 and (n1 > 29980.700294117647 or n2 > 29980.700294117647):
       k += 1
       mx = max(mx, abs(n2 - n1))

   # Обновляем значение предыдущего элемента
   n1 = n2

# Выводим количество пар и максимальную разность
print(k, mx)



# Задача (Полный квадрат)
# В файле содержится последовательность целых чисел. Элементы последовательности могут принимать целые значения от -10000 до 10000 включительно. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, в которых хотя бы одно число является полным квадратом некоторого натурального числа, 
# затем максимальную из сумм элементов таких пар. В данной задаче под парой подразумевается два подряд идущих элемента последовательности. 
# Например для последовательности из пяти элементов: 9; 15; 23; -3; 4 - ответ 2 24.

# Открываем файл для чтения
f = open('17_3.txt')
# Инициализируем счетчик количества пар и максимальную сумму
k = 0
mx = -10**10
# Читаем первый элемент последовательности
n1 = int(f.readline())
# Цикл по всем остальным элементам последовательности
for s in f.readlines():
   n2 = int(s)

   # Проверяем, является ли хотя бы одно число полным квадратом
   if (n1 > 0 and (round(n1 ** 0.5) ** 2) == n1) or (n2 > 0 and (round(n2 ** 0.5) ** 2) == n2):
       k += 1
       mx = max(mx, n1 + n2)

   # Обновляем значение предыдущего элемента
   n1 = n2
# Выводим количество пар и максимальную сумму
print(k, mx)



##Задача (Простое число)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно.
#  Определите количество пар последовательности, в которых хотя бы один элемент больше максимального простого числа в файле. 
# В ответе запишите количество найденных пар, затем минимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

#Решение:
def Pr(n):
    if n==1: return False
    for i in range(2, int(n**0.5)+1):
        if n%i==0:
            return False
    return True

f=open('17_2024_2.txt')

mx=-10**10

for s in f.readlines():
    x=int(s)
    if Pr(x):
        mx=max(mx, x)
print(mx)


#Простое число — это такое число, которое имеет ровно 2 различных делителя: единицу и само это число. 
# Функция Pr(n) проверят на простоту число n. Внутри функции пробегаемся с 2 до корня исследуемого числа. 
# Если хотя бы встретится один делитель в этом диапазоне, то число не простое и функция возвращает False. 
# В противном случае, возвращаем True. Почему достаточно идти до корня числа? - Читайте в статье по 25 Заданию.
#Единица не является простым числом.
#Получается число 99721.


f=open('17_2024_2.txt')

k=0
mn=10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 99721 or n2 > 99721:
        k += 1
        mn = min(mn, n1+n2)
    n1=n2

print(k, mn)



#Задача (Другая система счисления)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба элемента больше минимального числа во всей последовательности, которое в семеричной системе оканчивается на 3. 
# В ответе запишите количество найденных пар, затем максимальную сумму квадратов элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.

#Решение:
#Первым действием найдём минимальное число во всей последовательности, которое в семеричной системе оканчивается на 3.


f=open('17_2024_2.txt')

mn=10**10

for s in f.readlines():
    x=int(s)
    if x%7==3:
        mn=min(mn, x)
print(mn)

#Первый остаток при делении на 7 — это и есть последняя цифра в семеричной системе. Об это мы говорили в 14 Задании.
#Получается число 87.


f=open('17_2024_2.txt')

k=0
mx=-10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 87 and n2 > 87:
        k += 1
        mx = max(mx, n1**2 + n2**2)
    n1=n2

print(k, mx)




#Задача (Проверить первую цифру)
#В файле содержится последовательность натуральных чисел. 
# Элементы последовательности могут принимать целые значения от 1 до 100 000 включительно. 
# Определите количество пар последовательности, в которых оба элемента больше максимального числа во всей последовательности, 
# которое начинается на цифру "1". В ответе запишите количество найденных пар, затем минимальную сумму элементов таких пар. 
# В данной задаче под парой подразумевается два идущих подряд элемента последовательности.



#Решение:
#Первым действием найдём максимальное число во всей последовательности, которое начинается на цифру "1".


f=open('17_2024_2.txt')

mx=-10**10

for s in f.readlines():
    x = int(s)
    if str(x)[0] == '1':
        mx=max(mx, x)

print(mx)




#Получается число 19989. Здесь с помощью функции str() преобразовываем число x в строку и анализируем первый символ этой строки. 
# Если он равен символу "1", то это число допускаем до "Царя горы".


f=open('17_2024_2.txt')

k=0
mn=10**10

n1=int(f.readline())

for s in f.readlines():
    n2 = int(s)
    if n1 > 19989 and n2 > 19989:
        k += 1
        mn = min(mn, n1+n2)
    n1=n2

print(k, mn)


#Задача (Числа расположены в порядке возрастания)
#В файле 17-3.txt содержится последовательность целых чисел. 
# Элементы последовательности могут принимать целые значения от -10 000 до 10 000 включительно.
#  Определите и запишите в ответе сначала количество троек элементов последовательности, в которых числа расположены в порядке возрастания, 
# затем минимальную из разностей наибольшего и наименьшего элементов таких троек. 
# В данной задаче под тройкой подразумевается три идущих подряд элемента последовательности.



#Решение:
f=open('17-3.txt')

k=0
rz=10**10

n1=int(f.readline())
n2=int(f.readline())

for s in f.readlines():
    n3 = int(s)

    if n1 < n2 < n3:
        k += 1
        mx = max(n1, n2, n3)
        mn = min(n1, n2, n3)
        rz = min(rz, mx-mn)

    n1=n2
    n2=n3


print(k, rz)




#Задача (Любой порядок элементов)
#В файле содержится последовательность из 10 000 целых положительных чисел. Каждое число не превышает 10 000. 
# Определите и запишите в ответе сначала количество пар элементов последовательности, у которых сумма элементов кратна 9, затем максимальную из сумм элементов таких пар. 
# В данной задаче под парой подразумевается два различных элемента последовательности. 
# Порядок элементов в паре не важен.

#Решение:

#Первый способ (Красивый).

f = open('17.txt')

count_0 = 0
count_1 = 0
count_2 = 0
count_3 = 0
count_4 = 0
count_5 = 0
count_6 = 0
count_7 = 0
count_8 = 0


mx1_0 = 0
mx2_0 = 0
mx_1 = 0
mx_2 = 0
mx_3 = 0
mx_4 = 0
mx_5 = 0
mx_6 = 0
mx_7 = 0
mx_8 = 0


for s in f.readlines():
    n=int(s)

    if n%9==0:
        count_0 = count_0 + 1

        if n>mx1_0:
            if n>mx2_0:
                mx1_0 = mx2_0
                mx2_0 = n
            else:
                mx1_0 = n

    if n%9==1:
        count_1 = count_1 + 1
        mx_1 = max(mx_1, n)

    if n%9==2:
        count_2 = count_2 + 1
        mx_2 = max(mx_2, n)

    if n%9==3:
        count_3 = count_3 + 1
        mx_3 = max(mx_3, n)

    if n%9==4:
        count_4 = count_4 + 1
        mx_4 = max(mx_4, n)

    if n%9==5:
        count_5 = count_5 + 1
        mx_5 = max(mx_5, n)

    if n%9==6:
        count_6 = count_6 + 1
        mx_6 = max(mx_6, n)

    if n%9==7:
        count_7 = count_7 + 1
        mx_7 = max(mx_7, n)

    if n%9==8:
        count_8 = count_8 + 1
        mx_8 = max(mx_8, n)


count = (count_1*count_8) + (count_2*count_7)  + (count_3*count_6) + (count_4*count_5) + (count_0*(count_0-1)//2)
mx = max(mx_1 + mx_8, mx_2 + mx_7, mx_3 + mx_6, mx_4 + mx_5, mx1_0 + mx2_0)

print(count, mx)




#Здесь мы ищем количество элементов, у которых остаток при делении на 9 равен нулю, единице, двойке, ... и до 8. Подсчитываем эти данные соответственно в переменные count_0, count_1, count_2 ... и т.д.


#Так же находим максимальное число, которое имеет при делении на 9 остаток равный единице, двойке, ... и т.д. Для чисел, которые имеют остаток при делении на 9 ноль, находим два максимальных числа.


#После того, как результаты находятся в нужных переменных, можно вычислить ответ к задаче.


#Если, к примеру, взять число для которого остаток равен 1 и число для которого остаток равен 8, то их сумма будет делится на 9. Найдём количество пар, если нам известно количество и тех, и тех чисел.


#ЕГЭ по информатике 2022 - задание 17 (Числа не по порядку)

#Значит, просто нужно перемножить два числа, к примеру, count_1*count_8.


#Для чисел, которые делятся на 9 (т.е. остаток равен нулю), количество пар считается немного по-другому. Такие числа можно суммировать между собой, всё равно сумма тоже будет делится на 9. Путь есть у нас количество чисел count_0, которые делятся на 9. Тогда найдём количество пар, которые можно составить из этих элементов.


#Здесь вспомним метод умножения, о котором было написано в этой статье.


#ЕГЭ по информатике 2022 - задание 17 (Числа не по порядку)

#Найдём количество таких пар, если каждый элемент можно использовать 1 раз. Получается count_0*(count_0-1). Но т.к. в нашем случае пара, когда элементы находятся в одном порядке и в обратном, является одной и той же, то нужно это количество поделить на 2. Т.е количество пар будет (count_0*(count_0-1))/2.





#Второй способ (Перебор).

f = open('17.txt')

count=0
mx=0

a = []

#Считываем все числа в массив a
for s in f.readlines():
    n = int(s)
    a.append(n)

# Перебираем все варианты и подсчитываем пары, отвечающие условию задачи.
for i in range(0, len(a)):
    for j in range(i+1, len(a)):
        if (a[i]+a[j])%9==0:
            count = count + 1
            mx = max(a[i]+a[j], mx)
    

print(count, mx)

#В этом решении сначала считываем все числа в массив a.
#Далее берём число и начинаем его комбинировать со всеми числами, которые стоят после этого числа. 
#Таким образом, мы переберём все возможные комбинации, и у нас не будут пары повторяться.

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________

# 18 задание по информатике

#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________
#_______________________________________________________________________________________________________________________________________________________________





